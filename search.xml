<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[1510_shijain__shijianmaopao]]></title>
      <url>%2F2017%2F04%2F25%2F1510-shijain-shijianmaopao%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM节点查找，事件]]></title>
      <url>%2F2017%2F04%2F22%2FDOMorEVENT%2F</url>
      <content type="text"><![CDATA[DOM节点查找 属性名称 作用 children 子节点，不包含空节点 childNodes 子节点，包含空节点 firstChild 第一个子节点，包含空节点 firstElementChild 第一个子节点，不包含空节点 lastChild 最后一个子节点，包含空节点 lastElementChild 最后一个子节点，不包含空节点 nextSibling 下一个兄弟节点，包含空节点 nextElementSibling 下一个兄弟节点，不包含空节点 previousSibling 前一个兄弟节点，包含空节点 previousElementSibling 前一个兄弟节点，不包含空节点 parentNode 父节点 offsetParent 第一个有定位属性的父节点，如果没有，则返回body 事件 onload 图片或页面加载完成 焦点事件:onfocus/onblur 获得焦点/失去焦点 onchange 表单内容发送改变 onclick 点击 ondblclick 点击两次 onkeydown 键盘按下 onkeyup 键盘抬起 获取对象 、 兼容处理 12345 document.onkeydown = function(ev)&#123;var ev = ev || window.event;//获取事件对象兼容处理，一般浏览器直接在function参//数ev获取,ie浏览器通过window.event获取document.write(ev.keyCode);&#125; 键盘event对象属性 keyCode onmousedown 鼠标按下 onmouseup 鼠标抬起 onmousemove 鼠标移动 onmouseover 移到对象上 onmouseout 鼠标离开 鼠标event对象属性 clientX clientY onselect 在文本框中的文本被选中时发生,支持&lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt; onsubmit 在表单中的提交按钮被点击时触发 onreset 在表单中的重置按钮被点击时触发 onerror 在文档或图像加载过程中发生错误时被触发 阻止默认事件preventDefault() 或者 return false； 事件的触发机制事件的触发机制 上一级标签开始往下查找，直到捕获到事件目标(target)。 事件冒泡阶段： 事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。 事件冒泡冒泡详解： 如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播,不是所有的事件都能冒泡。 blur、 focus、 load和unload不能像其它事件一样冒泡。 阻止冒泡 IE中使用cancelBubble=true，Firefox中使用stopPropation()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式2,DOM]]></title>
      <url>%2F2017%2F04%2F22%2FzhengzeORdom%2F</url>
      <content type="text"><![CDATA[正则表达式 2 转义字符 功能 \n 换行符 \r 回车符 \t 制表符 \f 换页符 \cX 与x对应的控制字符 \v 垂直制表符 \b 退格符 \0 空字符”” .(点) 匹配除换行符之外的任一个字符，IE下[^\n],其他[^\n\r] \d 匹配数字[0-9] \D 匹配非数字字符 \w 匹配字母数字和下划线[a-zA-Z0-9_] \W 匹配除字母数字下划线之外的字符 [^azA-Z0-9_] \s 匹配一个空白字符 [ \n\r\t\f\x0B] \S 匹配一个非空白字符 [^ \n\r\t\f\x0B] \b 独立部分（起始、结束、空格） \B 非独立部分 \1 第一个匹配子项的重复匹配 量词 功能 {n,m} 至少出现n次，最多m次 {n,} 至少出现n次， * 任意次{0，} ？ 零次或者一次{0,1} + 一次或任意次{1,} {n} 正好n次 1234//例子//？ 零次或一次 &#123;0,1&#125; var reg09 = /a?/; document.write( reg09.test("aabbcc") +"&lt;/br&gt;"); 首尾 ^匹配起始位置 例：/^a/－表示须以字母a开始 $ 匹配结束位置 例：/t$/－表示须以字母t结尾 选择分组与引用 分组用() 常用正则表达式 功能 [\u4e00-\u9fa5] 匹配中文 ^\s* \s*$ 行首行尾空格 ^\w+@[a-z0-9]+(.[a-z]+){1,3}$ EMAIL [a-zA-z]+://[^\s]* 网址 [1-9][0-9]{4,9} QQ号 [1-9]\d{5} 邮政编码 [1-9]\d{5} 邮政编码 [1-9]\d{14} [1-9]\d{17} [1-9]\d{16}x 身份证号 DOM 分析DOM节点123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;DOM 教程&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;DOM 第一节&lt;/h1&gt; 、&lt;p&gt;Hello world!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 分析父、子和同胞节点：·&lt;html&gt; 节点没有父节点，它是根节点 &lt;head&gt; 和 &lt;body&gt; 的父节点是&lt;html&gt; 节点 ；文本节点 “ Hello world!”的父节点是 &lt;p&gt; 节点 获取节点 由id获取 getElementById 语法：node.getElementById(&quot;id&quot;); 例: document.getElementById(&quot;intro&quot;); 由class获取 getElementsByClassName 语法：node. getElementsByClassName(&quot;class&quot;); 例：document. getElementsByClassName(&quot; class &quot;); 由标签名获取 getElementsByTagName 语法：node. getElementsByTagName(“h1 &quot;); 查看节点类型 语法： nodeObject.[nodeType][nodeName ][nodeValue ] nodeType 返回以数字值返回指定节点的节点类型。如果节点是元素节点，则返回 1。如果节点是属性节点，则返回 2。 nodeName 返回节点名称（大写的标签名） nodeValue 文本节点返回文本内容，其他节点返回null DOM属性获取与设置 获取方法： element[attributename] element . attributename getAttribute( attributename ) 设置属性： setAttribute( attributename, attri 删除属性： removeAttribute( attributename) 常用属性： className 类名 offsetWidth 宽 offsetHeight 高 offsetLeft,offsetTop获取距离第一个定位父节点左上角的距离 操作子节点创建节点 createElement( )子节点的增删改 appendChild 在DOM子集最后添加子节点 insertBefore 在指定的已有子节点之前插入新的子节点 removeChild 删除一个节点 replaceChild 替换节点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Math对象,Date对象,正则表达式]]></title>
      <url>%2F2017%2F04%2F21%2FMathDate%2F</url>
      <content type="text"><![CDATA[Math 对象 作用： Javascript中，Math 对象是用于执行数学任务的对象(取整、取余。) 访问语法：MAth.属性名 注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。 属性和方法 abs(x)返回数的绝对值 ceil(x)对数进行上取整 floor(x)对数进行下取整 max(x,y)返回 x 和 y 中的最高值 min(x,y)返回 x 和 y 中的最低值 round(x)把数四舍五入为最接近的整数 pow(x,y)返回 x 的 y 次幂 random()返回 0 ~ 1 之间的随机数 sqrt(x)返回数的平方根 Date 对象 作用 : Javascript中， Date 对象用于处理日期和时间 创建 Date 对象的语法： var myDate=new Date() 属性 constructor返回对创建此对象的 Date 函数的引用 prototype使您有能力向对象添加属性和方法。 获取时间方法 ： Date()返回当日的日期和时间 getDate()从 Date 对象返回一个月中的某一天 (1 ~ 31) getDay()从 Date 对象返回一周中的某一天 (0 ~ 6) getMonth()从 Date 对象返回月份 (0 ~ 11) getFullYear()从 Date 对象以四位数字返回年份 getHours()返回 Date 对象的小时 (0 ~ 23) getMinutes()返回 Date 对象的分钟 (0 ~ 59) getSeconds()返回 Date 对象的秒数 (0 ~ 59) getMilliseconds()返回 Date 对象的毫秒(0 ~ 999) getTime()返回 1970 年 1 月 1 日至今的毫秒数获取时间的其他方法 getTimezoneOffset()返回本地时间不格林威治标准时间(GMT) 的分钟差 getUTCDate()根据世界时从Date 对象返回月中的一天 (1~31) getUTCDay()根据世界时从 Date 对象返回周中的一天 (0 ~ 6) getUTCMonth()根据世界时从 Date 对象返回月份 (0 ~ 11) getUTCFullYear()根据世界时从 Date 对象返回四位数的年份 getUTCHours()根据世界时返回 Date 对象的小时 (0 ~ 23) getUTCMinutes()根据世界时返回 Date 对象的分钟 (0 ~ 59) getUTCSeconds()根据世界时返回 Date 对象的秒钟 (0 ~ 59) getUTCMilliseconds()根据世界时返回 Date 对象的毫秒(0~ 999) parse()返回1970年1月1日午夜到指定日期（字符串）的毫秒数 设置时间方法： setHours()设置 Date 对象中的小时 (0 ~ 23) setMinutes()设置 Date 对象中的分钟 (0 ~ 59) setSeconds()设置 Date 对象中的秒钟 (0 ~ 59) setMilliseconds()设置 Date 对象中的毫秒 (0 ~ 999) setTime()以毫秒设置 Date 对象设置时间的其他方法 setUTCDate()根据世界时设置 Date 对象中月份的一天 (1 ~ 31) setUTCMonth()根据世界时设置 Date 对象中的月份 (0 ~ 11) setUTCFullYear()根据世界时设置 Date 对象中的年份（四位数字） setUTCHours()根据世界时设置 Date 对象中的小时 (0 ~ 23) setUTCMinutes()根据世界时设置 Date 对象中的分钟 (0 ~ 59) setUTCSeconds()根据世界时设置 Date 对象中的秒钟 (0 ~ 59) setUTCMilliseconds()根据世界时设置 Date 对象中的毫秒 (0 ~ 999) Date的其他方法: toSource()返回该对象的源代码 toString()把 Date 对象转换为字符串 toTimeString()把 Date 对象的时间部分转换为字符串 toDateString()把 Date 对象的日期部分转换为字符串 toUTCString()根据世界时，把 Date 对象转换为字符串。 toLocaleString()根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString()根据本地时间格式，把 Date 对象的时间部分转换为字符串 toLocaleDateString()根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC()根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf()返回 Date 对象的原始值 正则表达式 概念: 正则表达式 （Regular Expression、 regex），是使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。 作用: 测试字符串 、 替换文本 、 从字符串中匹配提取一个子字符串 声明方式: 12例1：var myRegExp=/内容 /例2：var myRegExp= new RegExp(“ 内容” ) **注意:** &gt; `斜杠（/内容/）表示正则表达式的开始和结束；` `声明方式第一种更简短有效，通常我们都用第一种；` 正则表达式方法: test(),匹配一个字符串是否符合正则规则，成功，则返回true match(),找到一个戒多个正则表达式的匹配 replace(),替换与正则表达式匹配的子串 search(),检索与正则表达式相匹配的值 split(),把字符串分割为字符串数组 5 正则表达式修饰符 全局匹配,修饰符g /…./g 例如： 123456var str04 = "aacbmaa";var reg04 = /a/g;document.write( str04.replace(reg04, "m") )//输出：mmcbmmm;//如果去掉g: var reg04 = /a/;//输出：macbmaa; 不区分大小写,修饰符i /…../I 就是将Paul和paul视为相同的字符模式 直接量字符 任意字符 ： [abc] 范围 ： [a-z]、 [0-9] 排除 ： [^a] 组合 ： [a-z0-9A-Z]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5与CSS3权威指南(完整版)]]></title>
      <url>%2F2017%2F04%2F19%2Fhtml-css-quanweipdf%2F</url>
      <content type="text"><![CDATA[HTML 5与CSS 3指南（第3版）是HTML 5与CSS 3领域公认的标杆之作，被读者誉为“系统学习HTML 5与CSS 3的著作”和“Web前端工程师案头必备图书之一”。 不仅是HTML 5与CSS 3图书领域当之无愧的领头羊，而且在整个原创计算机图书领域是佼佼者。 第3版首先从技术的角度根据的HTML 5和CSS 3标准进行了更新和补充，其次根据读者的反馈对内容的组织结构和写作方式做了进一步的优化，内容更经典，阅读体验也更好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML 5+CSS3从入门到精通]]></title>
      <url>%2F2017%2F04%2F19%2Fhtml-css-pdf%2F</url>
      <content type="text"><![CDATA[HTML5+CSS3从入门到精通是通过基础知识+中小实例+综合案例的方式，讲述了用HTML5+ CSS3设计构建网站的必备知识，相对于专业指南、高级程序设计、开发指南同类图书，本书是一本适合快速入手的自学教程。内容有：创建HTML5文档，实战HTML5表单，实战HTML5绘画，HTML5音频与视频，Web存储，离线应用，Workers多线程处理，Geolocation地理位置等技术。CSS3部分主要介绍了CSS3概述，CSS选择器，文本、字体与颜色，背景和边框，2D变形，设计动画，网页布局、用户界面以及CSS3的其他新特性。《HTML5+CSS3从入门到精通》内容涵盖了HTML5+CSS3的所有重要特性，通过大量实际案例对HTML5+CSS3的重要特性进行了详细讲解，内容全面丰富，易于理解，能够帮助读者提升实际应用技能。 《HTML5+CSS3从入门到精通》内容翔实、结构清晰、循序渐进，基础知识与案例实战紧密结合，既可作为HTML5+CSS3初学者的入门教材，也适合作为中高级用户对新技术作进一步学习的参考用书。本书显著特色有： 1．同步视频讲解，让学习更为直观高效。227节大型高清同步视频讲解，先看视频再学习效率更高。 2．海量精彩实例，用实例学更轻松快捷。225个精彩实例，模仿练习是最快捷的学习方式。 3．精选实战案例，为高薪就业牵线搭桥。31个实战案例展示可为以后就业积累经验。 4．完整学习套餐，为读者提供贴心服务。参考手册11部、网页模版83类、素材源程序，让学习更加方便。 5．讲解通俗翔实，看得懂学得会才是硬道理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript权威指南(第六版)中文扫描版]]></title>
      <url>%2F2017%2F04%2F19%2Fjavascriptquanweizhinan%2F</url>
      <content type="text"><![CDATA[《JavaScript权威指南（第6版）》主要讲述的内容涵盖JavaScript语言本身，以及Web浏览器所实现的JavaScript API。本书第6版涵盖了HTML5和ECMAScript 5，很多章节完全重写，增加了当今Web开发的最佳实践的内容，新增的章节包括jQuery、服务器端JavaScript、图形编程以及 JavaScript式的面向对象。本书不仅适合初学者系统学习，也适合有经验的 JavaScript 开发者随手翻阅。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript高级程序设计(第3版)]]></title>
      <url>%2F2017%2F04%2F19%2FJavaScriptgaojichengxusheji%2F</url>
      <content type="text"><![CDATA[《JavaScript高级程序设计(第3版)》是JavaScript超级畅销书的最新版。ECMAScript5和HTML5在标准之争中双双胜出，使大量专有实现和客户端扩展正式进入规范，同时也为JavaScript增添了很多适应未来发展的新特性。《JavaScript高级程序设计》这一版除增加5章全新内容外，其他章节也有较大幅度的增补和修订，新内容篇幅约占三分之一。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript字符串操作、 JSON、 this]]></title>
      <url>%2F2017%2F04%2F14%2F1101-json%2F</url>
      <content type="text"><![CDATA[JS字符串操作 “字符串对象”是Javascript内置的字符块处理对象，用于定义及处理字符串。 声明字符串的两种方法: var str1 = &quot;string1&quot; ; var str2 = new String(&quot;string2&quot;); 两种方式的差别:str1是一个字符串，类型是string ，而str2则是对象“ string2”的引用，类型是对象。如果引用被修改，str2也会被修改 字符串操作方法 charAt() 返回指定位置的字符 charCodeAt() 返回指定位置的字符的Unicode编码 search() 用于检索字符串中指定的子字符串 replace() 查找匹配指定的字符串，然后用新字符串代替匹配的字符串 concat() 将两个戒多个字符的文本组合起来，返回一个新的字符串 使用加号链接字符串。 newStr = “string1”+”string2” indexOf() 返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回 -1 lastIndexOf() 返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回 -1 slice() 提取字符串的一部分，并返回一个新字符串。两个参数，第一个为起始位置，第二个为终止位置（留头不留尾），如果没有end，就取到末尾 substring() 返回字符串的一个子串。传入参数是起始位置和结束位置。（留头不留尾），如果没有end，就取到末尾 split() 通过将字符串划分成子串，将一个字符串做成一个字符串数组。 Length 返回字符串的长度（其包含的字符的个数） toLowerCase() 将整个字符串转成小写字母 toUpperCase() 将整个字符串转成大写字母 转义字符 \我们平时想输出一个双引号（“”）我们会这样写：document.write(“””);但是这样写是错诨的,所以我们需要用到转义字符：document.write(“ \””); JSON JSON，全称是JavaScript Object Notation。它是基于JavaScript编程诧言ECMA-262 3rd EditionDecember 1999标准的一种轻量级的数据交换格式，主要用于跟服务器进行交换数据。跟XML相类似，它独立诧言，在跨平台数据传输上有很大的优势。 JSON的书写格式： 格式一：{ “name”:“ xiaoming”, “age”:“22”, “email”:&quot;jone@163.com&quot; }; 格式二: 12345678&#123;"name":"xiaoming", "age":"22", "friends":[ &#123;"name":&#123;"firstName":"liu","lastName":"wei"&#125;,"age":"23"&#125;, &#123;"name":&#123;"firstName":"li","lastName":"mei"&#125;,"age":"27"&#125; ] &#125; 取值 用“点”来取得相应的值，如JSON.name JSON和字符串之间转换 JSON.stringify(json) JSON.parse(str) JSON拷贝 深拷贝,浅拷贝 This 关键字 this概念 : this是Javascript诧言的一个关键字它代表函数运行时，自劢生成的一个内部对象，只能在函数内部使用 三种情况下的this指向: 纯粹的函数调用: this指向调用函数的对象 作为对象方法的调用: this指向window 作为构造函数调用: this指向构造函数的实例 修改this指向: 使用call()方法1. 语法：call(thisObj，Object) 2. 定义：调用一个对象的一个方法，以另一个对象替换当前对象 使用apply()方法1. 语法：apply(thisObj，[argArray]) 2. 定义：应用某一对象的一个方法，用另一个对象替换当前对象 使用new关键字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS函数,对象/类,定时器]]></title>
      <url>%2F2017%2F04%2F14%2F1001-function%2F</url>
      <content type="text"><![CDATA[JS函数,对象/类,定时器JS函数 JavaScript函数定义： 不带参数的函数 1234function functionname()&#123;//这里是要执行的代码&#125; &gt; 带参数的函数 1234function myFunction(var1,var2)&#123;//这里是要执行的代码&#125; &gt; 调用不带参数的函数 `myFunction()` &gt; 调用带参数的函数 `myFunction(argument1,argument2)` **在调用函数时，您可以向其传递值，这些值被称为参数。您可以发送任意多的参数，由逗号 (,) 分隔** 带有返回值的函数 123456function myFunction()&#123;var x=5;return x;&#125;var myVar=myFunction(); myVar 变量的值是 5也就是上面的函数返回值5 匿名函数(匿名函数就是没有实际名字的函数) 1234//匿名函数(function() &#123;alert('water');&#125;)(); 匿名函数的调用 要调用一个函数，我们必须要有方法定位它，引用它。所以，我们会需要帮它找一个名字。 1234var abc=function(x,y)&#123;return x+y;&#125;alert(abc(2,3)); JS对象/类 对象: 面向对象编程的核心 表示现实世界中的实体 为计算机应用程序提供实用基础 完成特定任务 对象是存在的具体实体，具有明确定义的状态和行为。对象：用来描述客观事物的一个实体，由一组属性和方法构成 类 具有相同属性和方法的一组对象的集合类是对象的类型类是模子，确定对象将会拥有的特征（属性）和行为（方法） 类的创建 123function class1()&#123;//类成员的定义及构造函数&#125; 创建一个学生类 每个学生都有年龄、姓名、班级和爱好。用类的思想编写学生类 123456function Students (name,age,grade,hobby)&#123;this.name=name; //姓名this. age=age; //年龄this. grade=grade; //班级this. Hobby=hobby; //爱好&#125; 为Students引用类型创建几个属性getName和setName方法： 123456Students.prototype.getName=function()&#123;return this.name;&#125;Students.prototype.setName=function(name)&#123;this.name=name;&#125; 创建和使用引用类型的实例 创建对象语法：var 对象名 = new 类名(); 123// 使用对象示例：var Student01=new Students("张三","20","2","唱歌");var Student02=new Students("李四","30","3","跳舞") 引用对象成员：使用“ .” 进行以下操作 类的创建不引用 属性：对象名.属性方法：对象名.方法名() 调用getName ()方法及age属性等，并将结果输出到页面上： 1document.write("我叫："+Student01.getName()+"年龄:"+Student01.age+",所在班级："+Student01.getGrade()+"，我的爱好是："+Student01.getHobby()+"。 "); JS定时器 JavaScript中有两类计时器，即一次性计时器和定期触发计时器。 一次性计时器仅在指定的时间后触发一次(setTimeout())定期触发计时器是每隔一定时间就触发一次(setInterval()) 一次性计时器： 使用window对象的setTimeout()方法 1Window.setTimeout(“function()&#123;&#125;”,delay) setTimeout()方法接收两参数，第一个是要执行的JavaScript代码，可以是一个函数，也可以是几个函数，函数间用“；”隔开即可。 12345//页面加载3秒后触发的计时器function hello()&#123;alert("hello");&#125;window.setTimeout(hello,3000); 清除定时器 clearTimeout(定时器id) 定期触发计时器 setInterval()方法的参数不setTimeout()方法相同，但第二个参数丌是计时器触发前的时间，而是计时器的触发间隔，该间隔以毫秒为单位。Var myTimerID=setInterval(“ myFunction(){}”,5000); 清除定时器window.clearInterval(timer2) 两者的区别在: 一个只执行一次,另一个没过一段时间就 执行一次; 总结 函数 不带参数的函数,带参数的函数,匿名函数,函数返回值 对象, 类 概念,创建,使用 定时器 概念,创建,使用setTimeout(), clearTimeout(),setInterval(),clearIearval()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手告诉你如何安装多个版本的node]]></title>
      <url>%2F2017%2F04%2F13%2Fnodejs%2F</url>
      <content type="text"><![CDATA[最近好多人都问到node怎么同时安装多个版本? 如何配置node的环境变量,如何自如的在多个版本中切换node?因为这种种原因,所有打算写一篇文章来专门讲解如何安装多个版本的node!!! node版本可以去 node中网网 或者到我的 百度云盘 下载 安装多个版本的node的时候一定要从低版本开始安装,如果你先安装高版本的话会出现许多问题,如果你已经安装啦,先卸载掉然后进行下面的步骤 下载后得到啦安装包,有32位和64位的多版本安装包,用户根据自己系统自行选择 在安装node之前,我先选择一个node安装目录,我要安装到D盘下,所有我在D盘中新建啦一个node的目录,并且在里面创建啦一个4.42的文件夹,应为我一会要在这个文件夹中安装4.42版本的node 开始安装: 打开node4.42的安装包,一直点击下一步,直到出现安装路径: 安装路径更改我们创建的那个4.42文件夹的路径,然后一路下一步,安装成功后文件夹内出现啦好多文件,这个时候node就安装好啦 把里面的路径改成D:\node\4.42\ node安装好后是不是就能用啦呢?当然不是,你还需要配置环境变量 计算机=&gt; 属性=&gt; 高级系统设置=&gt;环境变量 在系统变量中点击新建,变量名:node_4.42,变量值就是你4.42版本的安装目录,也就是D:\node\4.42\ 点击确定后再系统变量中找到path 变量,选中后点击编辑 看到path变量中的值啦嘛?我们把刚才新建的变量添加到这里面,如何添加呢? 一对%号,中间写上刚才新建的变量明,然后放到path中的最后面,一定不能忘啦中间的;号,每条变量中间都应该有个; 放好后点击确定,然后咱们打开CMD (win+R);输入: $ node -v 如何出现啦版本号,那么我们的第一个node已经安装完成并且可以正常使用啦; 安装多个版本:第一个安装好后安装第二个node版本; 在安装新的版本之前,我们需要做的就是先找到之前的那个版本的安装目录,也就是D:\node\4.42,然后把4.42这个文件夹给他重命名(因为你如果不修改名字的话你在安装新版本的时候无论你安装在什么地方,都会把之前的那个干掉): 修改后再创建一个新的目录,我给他取名叫5.11(因为我打算下一个安装5.11版本的) 接下来开始安装5.11就可以啦,还是和上面过程一样,直到配置完环境变量后我们的5.11就安装好啦. 安装好5.11的版本后咱们再回来吧4.42的那个目录改回来; 验证我们目前是否是安装了两个node版本:where node ,和当前使用的版本:node -v $ where node where node 出现啦两个,说明我们确实是安装啦两个版本的node,node -v 告诉我们当前使用的是哪个版本!!! 如果我们还要在安装其他版本的话方法也是一样的,按照上面的就可以啦 假如我们现在安装啦许多的node,但是当前的node版本不是我目前想用的怎么办呢?如何切换node版本呢? 打开环境变量,找到path.你想用哪个版本,就把哪个node变量放到所有node变量的最前面,比如我之前的path是%node_4.42%;%node_5.11%,我用的就是4.42的版本,我如果想用5.11的版本的话我就得把path里面的%node_4.42%;%node_5.11%改成%node_5.11%;%node_4.42% 2 这时候我们再看看: where node和node -v 这就是我们的安装多个版本node和node之间的版本切换;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webtool]]></title>
      <url>%2F2017%2F04%2F11%2Fwebtool%2F</url>
      <content type="text"><![CDATA[一些前端开发的干货@(前端乱炖) 标签（空格分隔）： 资料 出处:https://coding.net/u/f2e/p/Books/git/tree/master/%E7%A7%BB%E5%8A%A8Web包含pc端,移动端js库,框架,css框架,工具等等…在原文基础上添加修改 有些虽已经年代久远，但仍然可以学到很多有用的东西,可以整理资料的链接和其他链接资料或许有重复……–&gt;&gt;另外一个链接:分享自己长期关注的前端开发相关的优秀网站、博客、以及活跃开发者库 常用库查询系统常用库查询系统2 - 迷你库扩展库 es5-shim [es6-promise] (https://github.com/stefanpenner/es6-promise) 文档-avalon 2 中文文档-vue1.0 中文文档-vue2.0 中文文档 移动端资料 支付宝无线Web开发经验谈 移动前端系列——移动端页面坑与排坑技巧( 2014-12-08 ) 移动web最佳实践（2013） 移动Web前端框架 ( 2014 ) 移动端自适应方案-lib.flexible,淘宝手机版都是用这个框架 iOS 微信 音频 视频自动播放 解决ios下的微信打开的页面背景音乐无法自动播放 微信JS-SDK说明文档 微信js demo QQ浏览器X5内核问题汇总 手机分辨率查询 移动端响应式框架-测试阶段,不适用于复杂页面 学习资料/文章 渲染性能 awesome-javascript JavaScript教程 - 廖雪峰的官方网站 Github使用指南-从新手到专家 node.js中文资料导航 了不起的Nodejs Nodejs的各种资源,英文 AngularJS ,一些关于 AngularJS 的博客，文章，视频，书籍等 HelloSea.js seajs教程 HTTP API 设计指南 JSON API：用 JSON 构建 API 的标准指南中文版 了不起的React React的各种资源,英文 一家伙（s5s5）学习css3动画的心得 让WEB前端的变优雅的东东，如：代码规范，代码组织，最佳实践之类 前端工具推荐 设计规范 -强烈推荐看 腾讯团队web移动文章 视觉设计师是怎样让前端工程师 100% 实现设计效果的？ JavaScript 秘密花园 vue 教程 10 个原则让动画带你飞 React Native 中文网 cssreference.io 大话设计模式 书籍资料 免费的计算机编程类中文书籍 免费编程书籍 码农周刊整理-推荐关注 git资料 系列文章 React 入门实例教程 React-Native学习指南 html5 Canvas画图系列教程目录 web前端开发分享-目录系列 深入理解javascript原型和闭包系列 深入理解JavaScript系列 JavaScript模式集合 深入理解JavaScripts设计模式系列： 设计模式总结,非js 7 天打造前端性能监控系统 七天学会NodeJS 前端之困 · XSS CookBook系列 一个月时间整理《深入浅出Node.js》 【web必知必会】——图解HTTP 廖雪峰-JavaScript基础教程 MDN JavaScript基础教程 45个实用的JavaScript技巧、窍门和最佳实践 其他工具 flexbox在线制作器 SPARK动画平台 这是我们组做的一个动画效果平台，里面集合了所有的牛逼动画，可以让你灵感猛增！（目前已开放外网使用） OneDiv 这是个神奇的网站，里面的所有细节都是用一个div元素通过复杂的Css3实现的，有空可以去开开脑洞噢 贝塞尔曲线生成器 HTML5 与 CSS3 技术应用评估 各种奇妙的hack 几乎所有设备的屏幕尺寸与像素密度表 移动设备参数表 ios端移动设备参数速查 浏览器兼容表 移动设备查询器 移动设备适配库 移动设备适配库2 viewport与设备尺寸在线检测器 html5 移动端兼容性速查 在线转换字体 css3 选择器测试 兼容性速查表 浏览器的一些独特参数 各种各样的媒体查询收集 sass @include-media 媒体查询库 https://github.com/eduardoboucas/include-media css3 动画在线制作器 css3 渐变在线制作器 移动端手势表 webkit独有的样式分析 HTML5 Cross Browser Polyfills HTML5 POLYFILLS iPhone 6 屏幕揭秘 智图客户端 – 你的图片你做主,本地图片快速压缩工具 网站视频/音乐 扒神器 ###js插件网站 jquer.in OpenLib–http://www.open-lib.com/ Query插件库–http://www.jq22.com/ jquery之家–http://www.htmleaf.com/ 分享天空–http://www.sharetk.com/ jQuery Script–http://www.jqueryscript.net/ dowebok 做好网站–http://www.dowebok.com/ Web前端开发–http://www.zjgsq.com/ 前端组件库 搭建web app常用的样式/组件等收集列表(移动优先) 手势库 TouchSwipe vue ui组件库 微信UI Vux 支持@^1.0.24 bootstrap风格 Vux 支持@v1.x.x material风格 vue-mdl Keen-UI Mint UI iView UI element UI 支持vue@2.0 Muse-UI - 基于 Vue 2.0 和 Material Desigin 的 UI 组件库 前端自动化(Workflow) 前端构建工具 Yeoman - a set of tools for automating development workflow gulp - The streaming build system grunt - the JavaScript Task Runner F.I.S - 前端集成解决方案 前端模块管理器 Bower - A package manager for the web Browserify Component Duo RequireJS Sea.js webpack css预处理器 Less - Less is More , Than CSS Sass - Syntactically Awesome Style Sheets Stylus - Expressive, dynamic, robust CSS 1. 前端框架(Frameworks) Material-UI 移动端ui框架,效果好 github Frozen UI 腾讯移动UI框架 Bootstrap Foundation Amaze UI Semantic UI Pure CSS topcoat UIkit Material UI Framework7 mui ionic framework Fries jQuery Mobile H-ui 前端框架 Skeleton 2. JavaScript 框架汇总 JavaScript 框架 react Angular jQuery Backbone.js Ractive.js KISSY Zepto.js ZeptoBuilder是Zepto的一个在线版本，从列表中选取你想包含的文件，就能得到你自定义的构建了 Vanilla JS Avalon Sprint.js - 一个高性能、小体积的 DOM 操作库 (Benjamin De Cock) JSLite.js 轻量级JavaScript框架 Min.js - Super minimal selector and event library skel.js - A lightweight responsive framework [LAB.js 异步加载js] JavaScript 工具库 underscore.js Way.js - 双向数据绑定库 Keys.js - 应用快捷键 Mousetrap - 键盘快捷键操作 Vue.js - 数据驱动的组件化MVVM库 移动web开发调试工具AlloyLever介绍 - 打印信息 vConsole.js 同上 3. 前端游戏框架(动画引擎) Hilo 跨终端的互动游戏解决方案 阿里出品 Pixi.js 3.0.7 - WebGL 国外游戏引擎 https://github.com/pixijs/pixi.js cocos2d-html5 Egret Engine LimeJS EaselJS three.js AlloyStick The-Best-JS-Game-Framework CanvasEngine Quintus LayaAir 引擎 国内游戏框架,跟白鹭比较??暂时不知道 soya2d 一个 好学、易用、强大、开源的 H5游戏引擎 现在,有你掌控 4. ui组件库 GMU - 基于zepto的ui组件库，适用于移动端 FrozenUI - 腾讯移动端组件库 NEC NEJ Pure CSS Components magic-of-css Primer - The CSS toolkit and guidelines that power GitHub [ZUI - 一个开源前端实践方案，帮助你快速构现代跨屏应用。][1] [WeX5开源前端][2] [B-JUI][3] MUI 轻量级WEB框架 jQuery WeUI - V0.7.1 WeUI 的jQuery实现版，提供了大量官方WeUI没有的组件, 同时兼容 jQuery 和 Zepto。 Light7 手机ui组件 5. 基础模版 浏览器统一(Cross Browser) HTML5 BOILERPLATE Modernizr Normalize.css cssFx - 为CSS3自动生成浏览器前缀 -prefix-free - Break free from CSS prefix hell 响应式 Responsive - 响应式布局 Enquire.js - Awesome Media Queries in JavaScript Free Wall - 创建桌面，移动和平板的动态网格布局 6. 排版 yue.css typo.css chinese-copywriting-guidelines - 中文文案排版指南 7. 网格系统 flex.css - 快速入门，极速布局 grid Flexbox Grid MasonJS - creating a perfect grid Juiced: a Flexbox CSS Framework Neutron 创建灵化、简洁网页布局的SASS框架 flexible.gs 灵活的响应式栅格布局CSS框架 Decorator - HTML, CSS, and JavaScrip 前端框架 minigrid.js 只有2KB的零依赖栅格布局-瀑布流 8. HTML5 API 应用 History.js - gracefully supports the HTML5 History/State APIs jquery-pjax - pushState+ajax jquery-address - Deep Linking Notify.js(Web Notifications API) 9. UA 识别 detector 10. 表单处理10.1 表单验证(Form Validator)/表单提示 Validator Parsley jquery.form.js - jQuery Form Plugin Validform validator.js jquery-validation - jQuery Validation Plugin formvalidator.js Fort.js – 表单填写进度提示 mailcheck - 用于检测email地址的域名 Floatlable.js - 输入时显示placeholder文本 jQuery Label Better 10.2 &lt; select &gt; 相关 Chosen Select2 bootstrap-select 10.3 单选框/复选框相关 iCheck - 增强复选框和单选按钮 10.4 上传组件 jQuery File Upload Plugin 百度 Web Uploader Uploadify Plupload Fine Uploader arale-upload - 轻量级 iframe and html5 file uploader Dropzone.js - drag’n’drop library拖拽上传 flow.js localResizeIMG3 - 前端本地客户端压缩图片，兼容IOS，Android，PC FileAPI - 是文件上传（单个/多个）、拖放支持、图像裁剪、大小调整、应用过滤器和获取文件信息-Resumable.JS 通过HTML5API提供了稳定可恢复的多文件上传功能。 10.5 日期选择 Both Date and Time picker widget based on twitter bootstrap GMU 日历组件 Mobiscroll Pikaday - 日期选择器 TimelineJS - 时间轴 10.6 取色 Colorpicker plugin for Twitter Bootstrap 10.7 标签插件(Tag) TaggingJS – 可以灵活定制的 jQuery 标签系统插件 selectize.js 10.8 自动完成插件 At.js - 一个Twitter/微博样式的@自动完成插件 jquery-textcomplete - 智能搜索提示框/自动补全 typeahead.js - a fast and fully-featured autocomplete library Awesomplete - 零依赖的简单自动完成插件 - github 10.9 样式修正 autosize - 使文本框自动适应所输入的内容 11. 图表绘制/图形库(Graphics) Highcharts Chart.js - 基于HTML5的JavaScript图表 百度 ECharts Chartist.js D3.js - A JavaScript visualization library for HTML and SVG. intro-to-d3 - a D3.js tutorial Bonsai - 一个功能强大的JavaScript图形库 Epoch - 漂亮、平稳流畅和高性能可视化的图表库 SVG 2D绘图 SVG Morpheus - SVG图形变形动画 12. 日期格式化 Moment.js - 日期处理 Smart Time Ago - 显示相对时间 FormatJS – 让你的 Web 应用程序国际化13. 页面交互 13.1 Slider slick - the last carousel you’ll ever need Swipe - the most accurate touch slider Swiper - 移动端/pc端滑动组件比较强大 - github iscroll - 简约模拟滑动层 iSlider - 移动端滑动组件 OwlCarousel - create beautiful responsive carousel slider jquery-mousewheel - jQuery鼠标滚轮滚动侦测插件 Glide.js - 轻量级滑块组件 13.2 瀑布流 Masonry Isotope - Filter &amp; sort magical layouts 13.3 懒加载/加载监听/预加载 layzr.js - git关注蛮高的 - github imagesLoaded Echo.js lazySizes jquery_lazyload BttrLazyLoading lazyload.js waitForImages - 图片加载监听库 PxLoader - JS预加载库:实现图片、声音等各种文件的预加载功能 jQuery.preload - 预加载图片资源 bindWithDelay - jQuery Plugin For Delayed Event Execution TypeWatch - 停止输入时调用 13.4 图片轮播(幻灯片)/图片展示 SuperSlide - 国产的幻灯片,功能集成比较多,我个人推荐 FlexSlider unslider - 小而美的轮播库 prettyPhoto FlickerPlate - A cool jQuery plugin that lets you flick through content. Holder.js - Client-side image placeholders. RowGrid.js - 在径直的行里放置图片 ImageLightbox.js - 灯箱效果 JQuery Panorama Viewer - 全景视图 PhotoSwipe - 移动开发必备的 iOS 风格相册 - github 13.5 图片剪裁/图片处理 Jcrop - Image Cropping Plugin for jQuery croppic - an image cropping jquery plugin jQuery.eraser - 图像擦除插件 DD_belatedPNG.js - 让IE6支持透明PNG图片 FocusPoint.js 实现图片的响应式裁剪 Picturefill - 一个响应式图片 JS 插件 (Scott Jehl) jQuery picZoomer - 图片区域放大 watermark.js 为图片添加水印 13.6 进度条/加载动画(Loading) NProgress.js progress.js Pace - Automatic page load progress bar jquery-ajax-progress waitMe - 很漂亮的loading效果 spin.js sonic.js fakeLoader.js - 依赖jQ的全屏加载js Easy Pie Chart 13.7 侧滑插件(offcancas) pushy - a responsive off-canvas navigation menu Slideout.js - 一个用于移动 Web 应用的触摸滑出式导航菜单 13.8 菜单(Menu) SuperFish - 基于jQuery的级联下拉菜单 Responsive Nav - 响应式导航 13.9 滚动侦测(ScrollSpy) jquery-scrollspy(1) jquery-scrollspy(2) Waypoints ScrollMagic - 像进度条一样使用滚动条 onScreen - 滚动加载,滚动固定 13.10 滚动加载更多/下拉刷新(Pull to Refresh) jScroll web-pull-to-refresh pulltorefresh RubberBand.js - add pull-to-refresh functionality to any page. infinity.js/∞ .js 无限下拉加载 13.11 平滑滚动插件(Smooth Scroll) jquery-smooth-scroll jquery.scrollTo - 平滑滚动到页面指定位置 smooth-scroll scrollUp Elevator.js 一个模拟电梯运行“返回顶部”的 JS 插件 (Tim Holman) 13.12 全屏滚动/全屏切换 pagePiling.js - 全屏滚动效果 fullPage.js onepage-scroll zepto.fullpage - 专注于移动端的fullPage.js screenfull.js - 切换全屏模式 Space.js – HTML 驱动的页面 3D 滚动效果 - github 13.13 分屏滚动 multiscroll.js - 分屏滚动效果 13.14 转场效果 Animsition - 页面切换时的过渡效果 13.15 固定元素(Sticky) Sticky-Kit 比较出名,功能强大,个人推荐 Sticky Navbar -可定点 Waypoints sticky - jQuery Plugin for Sticky Objects jquery.pin - 固定页面元素 stickUp Slinky.js - 堆叠头部创建滑动导航列表 Headroom.js ScrollMagic Sticky Float Sticky Mojo Zebra Pin HC-Sticky 13.16 触控事件 Hammer.js jquery.event.move.js 13.17 拖拽组件 Draggabilly - 专注于拖拽功能的 JS 库 13.18 隐藏或展示页面元素 Headroom.js - 在不需要页头时将其隐藏 Readmore.js - 内容显示与隐藏插件 oriDomi - 像指一样折叠Dom元素 13.19 滚动条(Scrollbar) jQuery-slimScroll pc效果不错5k,手机端不建议是用 jquery.mCustomScrollbar pc,苹果效果不错,安卓效果略差,大小较大 jScrollPane jquery.scrollbar perfect-scrollbar nanoScrollerJS tinyscrollbar 13.20 视差滚动(Parallax Scrolling) MidnightJS 效果很赞 parallax.js jparallax StickyStack.js -github jquery.superscrollorama.js 很酷的动画效果 14. 代码高亮插件/代码编辑器 google-code-prettify highlight.js Rainbow ACE CodeMirror Crayon Syntax Highlighter prism - Lightweight, robust, elegant syntax highlighting. 15. UI Icon 组件 Font Awesome Glyphter: The SVG Font Machine Perfect Icons iconizr Cikonss - 纯CSS实现的响应式Icon Simple Icons 16. 动画(Animate) js动画库 GSAP.js 最屌的动画库 Animate Plus CSS/SVG 动画库 anime.js 最近出的动画库,支持svg dynamics.js js动画-很屌的样子,支持svg snabbt.js - 简约的JavaScript动画库 Transit - CSS transitions and transformations for jQuery Move.js - 简化CSS3动画的JS库 - github Animo.js - 堆栈动画，创建跨浏览器的模糊效果【效果不错，依赖jq】 - github Velocity.js - 加速JavaScript动画 Morf.js 提供了一组 JavaScript 方法用于加速 CSS3的各种转换效果，支持的方法都在上图中，无需编写 CSS3 代码。 - github lenticular.js - 响应倾斜或鼠标事件创建图片动画 jQuery Interactive 3D - 使用图片创建一个3D模型 AnimateScroll - 动画滚动,应该是定点导航动画 jq 元素抖动库 Tween JS JavaScript 补间动画库 canvas Rekapi 关键帧动画库 favico.js v0.3.4 控制游览器标签小图标 - github dom-animator -注释动画 css动画库 xless - 又一个css动画库 github CSShake - css抖动库 - github animate.css - css3动画库 all animation - 同上,有sass版本 - github magic - CSS3动画特效 - gihub ScrollMe – 在网页中加入各种滚动动画效果 Loaders.css - css加载动画 - github css-loaders - 同上 Hover.css - github Effeckt.css - 手机动画库 NEC动画库 uilang - a minimal, ui-focused programming language for web designers csshake 带有sass版本 AniJS - 一个基于声明式语法的CSS动画库 SpinKit ?? JX.Animate - 腾讯css3动画库 - github 17. 本地存储 cross-storage - Cross domain local storage localForage pouchdb basil.js 18. 模板引擎 vue.js ie9+ paperclip.js ie8+ mustache.js Handlebars.js artTemplate baiduTemplate JSRender EJS - JavaScript Templates Juicer - A Light Javascript Templete Engine. Tempo json2html 19. 通知组件/弹框组件/模态窗口 layer.js - 国产,也是集成很多功能,个人推荐 AnimatedModal.js - CSS3 全屏模态窗口,支持 Firefox、Chrome、Safari、Opera 和 IE 10+ alertify.js AlertifyJS SweetAlert Messenger - 非常酷的弹框组件 PNotify Notify.js - A simple, versatile notification library Remodal - 模态窗口插件 20. 提示控件(Tooltips) qTip2 - Pretty powerful tooltips tooltip - CSS Tooltips tooltipster - A jQuery tooltip plugin grumble.js - 气泡形状的提示（Tooltip）控件 Ouibounce - 离站提示控件 21. 对话框/遮罩层/弹出层(lightbox) fancyBox - Fancy jQuery lightbox jquery-lightbox - The popular lightbox script, ported to jQuery Colorbox - a jQuery lightbox artDialog - 经典的网页对话框组件 DialogEffects jQuery blockUI - Page or element overlay 22. 文档/表格/PDF handsontable - 在线可编辑excel表格 jQuery Bootgrid - 用于ajax生成动态表格 DataTables - Table plug-in for jQuery PDF.js - 一个 JavaScript 编写的 PDF 阅读器 jsPDF - Generate PDF files in JavaScript Recline.js - 灵活操作和展示数据 Dynatable - 交互式表格插件 23. 目录树插件 zTree_v3 - jQuery Tree Plugin jstree - jQuery Tree Plugin fancytree - Tree plugin for jQuery 24. Ajax模块 fetch - A window.fetch JavaScript polyfill reqwest - browser asynchronous http requests minAjax.js 25. 音频/视频 jWebAudio jPlayer - HTML5 Audio &amp; Video for jQuery video.js - HTML5 &amp; Flash video player Accessible HTML5 Video Player - PayPal 开源的 HTML5 视频播放器 Clappr - 开源的Web视频播放器 Plyr - 简单，灵活的 HTML5 媒体播放器 FitVids.js - A lightweight, easy-to-use jQuery plugin for fluid width video embeds. BigVideo.js - The jQuery Plugin for Big Background Video BigScreen - A simple library for using the JavaScript Full Screen API Vide - 视频背景 winamp2-js Buzz - A Javascript HTML5 Audio library [howler.js 是一个新的 JavaScript 库用于处理 Web 的音频，该库最初是为一个 HTML5 游戏引擎所开发，但也可用于其他的 Web 项目。] (https://github.com/goldfire/howler.js) 26. 按钮 Buttons - A CSS button library ButtonComponentMorph ProgressButtonStyles CreativeButtons CSS3 buttons jquery.onoff - Interactive, accessible toggle switches for the web. 27. 富文本编辑器/Markdown编辑器/Markdown解析器 Simditor - 简单快速的富文本编辑器 BachEditor - 一个有情怀的编辑器 Squire – 简洁的 HTML5 富文本编辑器 TinyMCE bootstrap-markdown marked - markdown解析器 Markdown Plus Editor.md - 开源在线Markdown编辑器 28. 内容提取(Readability) Readability json.human.js - Json Formatting for Human Beings 29. 颜色(CSS Colors)/SVG CSS Colours SVGeneration SVGMagic - 自动的创建PNG来兼容不支持SVG的浏览器 Adaptive Backgrounds - 从图片抽取主要颜色和应用到父元素 30. 选项卡(Tabs) Easy Responsive Tabs to Accordion Responsive-Tabs ion.tabs - jQuery tabs plugin jQuery-EasyTabs 31. 文本处理 ZeroClipboard - 文本复制插件 Bigfoot - 点击文章中的脚注弹窗显示 Annotator - 文本注解插件，可以包括注释、标签、用户等 Succinct - 用作截断多行文本,后面添加省略号 Flowtype.js - 自动调整字体大小和行号 flat-shadow FitText - A jQuery plugin for inflating web type Squishy 是一个jQuery插件，它能自动调整文字，准确地对其各容器 slabText 一个jQuery插件，用于创建大的，大胆的和敏感的头条新闻。 Textillate 做CSS3文字动画。 Bacon 是一个jQuery插件，它允许您环绕贝塞尔曲线文字或线条，它可以让您的文字沿贝塞尔曲线排列。 Circletype.js 是一个很小的（ 2.7kb ）的jQuery插件，可以让你的字体在一个圆圈内显示。 jQSlickWrap 是一个jQuery插件，让您可以轻松而准确地环绕浮动图像里的内容文字。 TypeButter 使您能为您的字体设置透明度和字间距。 32. 布局(Layout) 分隔面板(Split Panel) split-pane 33. 实用工具/其他插件 jquery-cookie FastClick - 处理移动端 click 事件 300 毫秒延迟 Async.js - 异步操作 html2canvas - 实现纯JS网页截图 jquery.qrcode.js - 生成二维码的 jQuery 插件 nakedpassword - 用脱衣女帮助检测密码强度 KityMinder - 脑图编辑工具 MixitUp - 动画过滤和排序 JQuery Tip Cards - 创建卡片交互的cards布局 Fallback.js - JavaScript library for dynamically loading CSS and JS files. swfobject 34. sass 库 Family.scss - css3选择器简写框架,非常不错 SpaceBase – 基于 Sass 的响应式 CSS 框架 - github breakpoint-sass 媒体查询库 @include-media diy媒体查询库 sass-mediaqueries 媒体查询库-推荐 -demo sass-mq Media Queries with superpowers-em单位媒体查询库 34.1 分页 jqPagination 分页插件 35. 未知分类 Rainyday.js - 实现雨滴效果 Reveal.JS - 替代PPT,演示文稿。 Gif.JS 是一个能运行在你的浏览器中的JavaScript GIF编码器。 Sir Trevor是一个会完全重绘网页内容的工具：直观的编辑网页内容而不用假定任何关于它是如何重绘的事。 feature.js 检测浏览器是否支持某属性 Mock.js 生成随机数据,拦截ajax BookBlock 翻书特效 - github intro.js 引导用户页面 CSS滤镜 CSSgram Transformicons - CSS/SVG 元素模拟 图标/符号动画-过渡 CSS 滤镜在线调试 glfx.js canvas图片处理滤镜 Crayon.css CSS颜色变量名与16进制对应列表。 SVG圆形菜单生成器 优化和配置SVGO的WEB应用 CSS单位对比视图 使用GUI快速创建SVG path 把CSS代码转成SASS的应用 resizr 测试 CSS media queries 的轻量级应用-需要线上地址,没有线上地址,可以搞个coding-git 在线ppt flash文件转 canvas - Flash2x Tool http://www.annie2x.com/docs/ testcafe 浏览器测试工具-类似(测试单元工具)36. Canvas库 jCanvas - 语法简单实现canvas的js 库 create.js 前端参考集 frontend-guidelines - Some HTML, CSS and JS best practices. Codrops - Useful resources Front-end Code Standards &amp; Best Practices frontend-dev-bookmarks Airbnb 的 JavaScript 编码规范 Clusterize.js 可以优化你的大型数据表格的性能还有一大波干货待整理… 欢迎分享你的好东西给我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react]]></title>
      <url>%2F2017%2F04%2F11%2Freact%2F</url>
      <content type="text"><![CDATA[React简介###React是什么？ React是Facebook开源的一个用于构建用户界面的Javascript库，已经 应用于Facebook及旗下Instagram。 和庞大的AngularJS不同，React专注于MVC架构中的V，即视图。 这使得React很容易和开发者已有的开发栈进行融合。 这个项目本身也越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。衍生的 React Native 项目，目标更是宏伟，希望用写 Web App 的方式去写 Native App。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次 UI ，就能同时运行在服务器、浏览器和手机 ###官网地址 英文网：http://facebook.github.io/react/docs/getting-started.html 文档最新且更新快（推荐大家看这个） *中文网：http://reactjs.cn/react/docs/getting-started.html ###在线编辑工具在线编辑工具，可以方便我们快速学习react基本语法 ###为什么使用 React？我们创造 React 是为了解决一个问题：构建随着时间数据不断变化的大规模应用程序。为了达到这个目标，React 采用下面三个主要的思想。 简单 仅仅只要表达出你的应用程序在任一个时间点应该长的样子，然后当底层的数据变了，React 会自动处理所有用户界面的更新。 声明式 (Declarative) 数据变化后，React 概念上与点击“刷新”按钮类似，但仅会更新变化的部分。 构建可组合的组件 React 都是关于构建可复用的组件。事实上，通过 React 你唯一要做的事情就是构建组件。得益于其良好的封装性，组件使代码复用、测试和关注分离（separation of concerns）更加简单。 更多原因 http://facebook.github.io/react/blog/2013/06/05/why-react.html 实战案例 http://info.smartstudy.com/ http://www.kongkonghu.com/choice https://github.com/webpack/react-starter 入门视频 https://www.youtube.com/watch?v=7eLqKgp0eeY https://www.youtube.com/watch?v=fZKaq623y38&amp;list=PLQDnxXqV213JJFtDaG0aE9vqvp6Wm7nBg https://www.youtube.com/watch?v=QQK5hpUuOuA&amp;list=PLUAEXpf1UDMkzPOiNJBrlqsUryn7n2cnK 参考资料 https://github.com/dingyiming/learn-Js-react/issues/1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React的四个概念简单介绍]]></title>
      <url>%2F2017%2F04%2F11%2Freact-2%2F</url>
      <content type="text"><![CDATA[React的四个概念简单介绍React主要有四个主要概念构成，下面分别来介绍一下： ###Virtual DOM 虚拟DOM是React的基石。 之所以引入虚拟DOM，一方面是性能的考虑。Web应用和网站不同，一个Web应用 中通常会在单页内有大量的DOM操作，而这些DOM操作很慢。 在React中，应用程序在虚拟DOM上操作，这让React有了优化的机会。简单说， React在每次需要渲染时，会先比较当前DOM内容和待渲染内容的差异， 然后再决定如何最优地更新DOM。这个过程被称为reconciliation。 除了性能的考虑，React引入虚拟DOM更重要的意义是提供了一种一致的开发方 式来开发服务端应用、Web应用和手机端应用： 因为有了虚拟DOM这一层，所以通过配备不同的渲染器，就可以将虚拟DOM的内容 渲染到不同的平台。而应用开发者，使用JavaScript就可以通吃各个平台了。相当棒的思路！ Virtual DOM速度快的说明 在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何 进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前 整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟 DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化，而如果通过手动控 制，这种逻辑通常是极其复杂的。尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是 Diff部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要 关心在任意一个数据状态下，整个界面是如何Render的。详情查看 React组件 组件化概念 虚拟DOM(virtual-dom)不仅带来了简单的UI开发逻辑，同时也带来了组件化开发的思想，所谓组件，即封装起来的具有独立功能的UI部 件。React推荐以组件的方式去重新思考UI构成，将UI上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件， 最终完成整体UI的构建。例如，Facebook的instagram.com整站都采用了React来开发，整个页面就是一个大的组件，其中包含了嵌套 的大量其它组件，大家有兴趣可以看下它背后的代码。 如果说MVC的思想让你做到视图-数据-控制器的分离，那么组件化的思考方式则是带来了UI功能模块之间的分离。我们通过一个典型的Blog评论界面来看MVC和组件化开发思路的区别 对于MVC开发模式来说，开发者将三者定义成不同的类，实现了表现，数据，控制的分离。开发者更多的是从技术的角度来对UI进行拆分，实现松耦合。 对于React而言，则完全是一个新的思路，开发者从功能的角度出发，将UI分成不同的组件，每个组件都独立封装。在React中，你按照界面模块自然划分的方式来组织和编写你的代码，对于评论界面而言，整个UI是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立。 组件化开发特性React认为一个组件应该具有如下特征： 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件； 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景； 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护； 可测试（Testable）：因为每个组件都是独立的，那么对于各个组件分别测试显然要比对于整个UI进行测试容易的多。 组件定义在React中定义一个组件也是相当的容易，组件就是一个 实现预定义接口的JavaScript类： 组件渲染 ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); 而这个方法， 必须而且只能返回一个有效的React元素。这意味着，如果你的组件是由多个元素构成的，那么你必须在外边包一个顶层 元素，然后返回这个顶层元素。比如我们创建一个布局组件：12345678render:function()&#123; return React.createElement( "div",null, React.createElement("div",null,"header"), React.createElement("div",null,"content"), React.createElement("div",null,"footer") );&#125; ES5方式定义组件 12345678910111213"use strict";var HelloMessage = React.createClass(&#123; displayName: "HelloMessage",render: function render() &#123; return React.createElement( "div", null, "Hello ", this.props.name ); &#125; &#125;);ReactDOM.render(React.createElement(HelloMessage, &#123; name: "John" &#125;), mountNode); Jsx中定义组件 123456var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name="John" /&gt;, mountNode); ES6中定义组件 12345678910111213141516171819202122import './Hello.css';import './Hello.scss';import React, &#123;Component&#125; from 'react';// 内联样式let style=&#123; backgroundColor:'blue'&#125;export default class Hello extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 'es6'&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1 style=&#123;style&#125;&gt;Hello world&#123;this.state.count&#125;&lt;/h1&gt; &lt;br/&gt; &lt;image/&gt; &lt;/div&gt; ) &#125;&#125; 5 注意事项 （1）你的React组件名称的首字母应当大写，关于大小写的差异你会在后面发现。（2）你应该会注意到div元素的样式类是用 className而不是class声明的，这是因为class 是JavaScript的保留字，渲染后，真实的DOM还会是： &lt;div class=&quot;ez-led&quot;&gt;Hello, React!&lt;/div&gt; Jsx语法 什么是jsx 在用React写组件的时候，通常会用到JSX语法，粗看上去，像是在Javascript代码里直接写起了XML标签，实质上这只是一个语法糖，每一个 XML标签都会被JSX转换工具转换成纯Javascript代码，当然你想直接使用纯Javascript代码写也是可以的，只是利用JSX，组件的结 构和组件之间的关系看上去更加清晰 Jsx语法使用HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。 1234567891011var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')); 上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员12345678var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example')); 上面代码的arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板，运行结果如下。 Data Flow（单向数据流） 传统的mvc 到了 Flux 当中, 除了名字改变了, 重要的是大量的 Model 归到了 Store, View 也统一了,从而得到了所谓单向的数据流, 就是 Model 和 View 之间关系非常清晰了。这样需要人为管理的状态就一下少了很多, 结果体现在开发应用的效率当中: Flux 详细学习地址：https://hulufei.gitbooks.io/react-tutorial/content/flux.html React 标榜自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分，Flux 是 Facebook 使用的一套前端应用的架构模式。 一个 Flux 应用主要包含四个部分：1. dispatcher 处理动作分发，维护 Store 之间的依赖关系 2. stores 数据和逻辑部分 3. views React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互 4. actions 提供给 dispatcher 传递数据给 store 单向数据流先来了解一下 Flux 的核心“单向数据流“怎么运作的：Action -&gt; Dispatcher -&gt; Store -&gt; View更多时候 View 会通过用户交互触发 Action，所以一个简单完整的数据流类似这样： 整个流程如下： 首先要有 action，通过定义一些 action creator 方法根据需要创建 Action 提供给 dispatcher View 层通过用户交互（比如 onClick）会触发 Action Dispatcher 会分发触发的 Action 给所有注册的 Store 的回调函数 Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了 View 会监听这个 change 事件，拿到对应的新数据并调用 setState 更新组件 UI所有的状态都由 Store 来维护，通过 Action 传递数据，构成了如上所述的单向数据流循环，所以应用中的各部分分工就相当明确，高度解耦了。这种单向数据流使得整个系统都是透明可预测的。###ReduxRedux官方中文文档：http://camsong.github.io/redux-in-chinese/index.html Reflux：https://segmentfault.com/a/1190000002793786?utm_source=tuicool]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React快速开始+Recat主要知识内容]]></title>
      <url>%2F2017%2F04%2F11%2Freact-1%2F</url>
      <content type="text"><![CDATA[#React快速开始+Recat主要知识内容 ##快速开始 ###创建项目文件夹 npm init // 初始化npm配置文件 依赖环境在项目根目录下打开命令窗口下载react和react-dom依赖 npm install react react-dom --save 创建目录结构 Hello World看官网英文官网的：http://facebook.github.io/react/index.html123456789Var React=require(‘react’);Var ReactDOM=require(‘react-dom’);var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name="John" /&gt;, mountNode); 代码编译方式（语法转换）因为现在都是使用jsx和es6，所以我们需要对js代码进行编译。编译转换有分为浏览器中转换和离线转换，但是基本上公司不会用在浏览器中引入转换js转换，所以我们只介绍离线转换 react-tools转换这是react自己提供的，而且是老版本的，因为中文官网还是老版本的api，所以介绍的是这种方式。 npm install -g react-tools // 首先安装依赖 jsx --watch src/ build/ // 用命令进行转换，有兴趣的大家自己看一下jsx -h 参考地址：http://reactjs.cn/react/docs/getting-started.html babel转换英文官网的文档比较新，已经推荐使用babel来进行转换1.下载依赖123npm install --global babel-cli // 安装babelnpm install babel-preset-react -dev-save// 安装babel转换jsx的包npm install babel-preset-es2015 -dev-save// 安装babel转化ES6的包 注意:加了-dev之后，运行npm install不会下载开发依赖，你需要运行 npm install –dev //从github上下载之后运行这句才能下载开发依赖 运行命令进行编译 1babel --presets react src --watch --out-dir build // 更多命令可运行babel –h查看或者官网 将编译之后的js文件在index.html文件中引入 Gulp-reacthttps://github.com/sindresorhus/gulp-react 开发工具 ###语法版本说明从最新的版本上来看，未来都是要用es6语法 ##Recat主要知识内容 视图相关概念 Props（属性，就是element上的attrs，换个名字property，变成复数，即props） State（写过view组件的基本都会知道，按钮有三态，Normal，Highlight，Selected，包括extjs，jquery里的大部分ui框架都是有状态的。） Event（其实还应该算一个就是dom事件，上面的例子就把onChange的handler编译后的handleChange方法，这要感谢jsx）了解了上面这些，就可以写代码了，因为 属性，解决了view的定义问题，即语义描述 状态，是view的有穷状态机，根据状态决定组件ui和行为 事件，是view里元素的行为有穷状态机：http://baike.baidu.com/view/115336.htm jsx语法详解 HTML 转义（了解） React 会将所有要显示到 DOM 的字符串转义，防止 XSS。所以如果 JSX 中含有转义后的实体字符比如 © (©) 最后显示到 DOM 中不会正确显示，因为 React 自动把 © 中的特殊字符转义了。有几种解决办法： 直接使用 UTF-8 字符 © 使用对应字符的 Unicode 编码 使用数组组装 &lt;div&gt;{[&#39;cc &#39;, &lt;span&gt;©&lt;/span&gt;, &#39; 2015&#39;]}&lt;/div&gt; 直接插入原始的 HTML&lt;div dangerouslySetInnerHTML={`{__html: ‘cc © 2015’}} /&gt;` dangerouslySetInnerHTML参考文档 自定义 HTML 属性（了解） 如果在 JSX 中使用的属性不存在于 HTML 的规范中，这个属性会被忽略。如果要使用自定义属性，可以用 data- 前缀。文档估计有问题可访问性属性的前缀 aria- 也是支持的。与dom的区别文档：http://reactjs.cn/react/docs/dom-differences.html 支持的标签和属性 如果你要使用的某些标签或属性不在这些支持列表里面就可能被 React 忽略，必须要使用的话可以提 issue，或者用前面提到的 dangerouslySetInnerHTML。支持列表：http://reactjs.cn/react/docs/tags-and-attributes.html 并不是所有的html标签和属性都能在jsx语法中使用 基本上你能用到的标签的属性，jsx语法都支持 有些特殊的属性需要注意，必须class属性要变为className属性 所有的属性都是驼峰命名的，class 属性和 for 属性分别改为 className 和 htmlFor，来符合 DOM API 规范。 属性扩散有时候你需要给组件设置多个属性，你不想一个个写下这些属性，或者有时候你甚至不知道这些属性的名称，这时候 spread attributes 的功能就很有用了。 1234 var props = &#123;&#125;;props.foo = x;props.bar = y;var component = &lt;Component &#123;...props&#125; /&gt;; 123var props = &#123; foo: 'default' &#125;;var component = &lt;Component &#123;...props&#125; foo=&#123;'override'&#125; /&gt;;console.log(component.props.foo); // 'override' 自闭合标签 如果只有一个组件，就用单闭合标签形式，如果有多个组件嵌套就用双闭合标签形式http://reactjs.cn/react/tips/self-closing-tag.html 注释在 JSX 里使用注释也很简单，就是沿用 JavaScript，唯一要注意的是在一个组件的子元素位置使用注释要用 {} 包起来1234567891011var content = ( &lt;Nav&gt; &#123;/* child comment, put &#123;&#125; around */&#125; &lt;Person /* multi line comment */ name=&#123;window.isLoggedIn ? window.name : ''&#125; // end of line comment /&gt; &lt;/Nav&gt;); ###React的API 顶层APII 组件API组件的生命周期（特别重要）组件的生命周期，另外的名字是状态回调，和上面讲的状态的唯一差别，上面的状态是它里面的元素，而组件的生命周期是它自己https://hulufei.gitbooks.io/react-tutorial/content/component-lifecycle.html 组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 处理函数: React 为每个状态都提供了两种处理函数，will函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 函数调用顺序图 从上图中我们可以看出来，组件再初始化一次之后就不会再运行上图运行中文字以上的方法，反而里面会有事件监听，从而执行shouleComponentUpdate事件。 代码使用 ES5: 12345678910111213141516var Hello = React.createClass(&#123; getInitialState() &#123; return &#123; liked: false &#125;; &#125;, render: function() &#123; console.log(this.state.liked); return( &lt;div&gt; &lt;h1 style=&#123;style&#125;&gt;Hello world&lt;/h1&gt; &lt;br/&gt; &lt;image/&gt; &lt;/div&gt; ) &#125;&#125;);module.exports=Hello; ES6 12345678910111213141516export default class Hello extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 'es6'&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1 style=&#123;style&#125;&gt;Hello world&#123;this.state.count&#125;&lt;/h1&gt; &lt;br/&gt; &lt;image/&gt; &lt;/div&gt; ) &#125;&#125; 参考文章 生命周期详细介绍： http://www.cnblogs.com/CHONGCHONG2008/p/5099483.html http://pinggod.com/2015/React-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/ http://reactjs.cn/react/docs/component-specs.html 在ES6中用ES5的写法会报错 ES5/ES6最新写法对照表React的：http://www.tuicool.com/articles/equ2my ReactNative的http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8/2 ###事件处理 使用onClick这种进行驼峰命名ES5和ES6的写法不一样，在ES6中要用bind方法绑定this(具体可参照ES5和ES6写法对照表) 12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import &#123; render &#125; from 'react-dom';export default class LinkButton extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;liked: false&#125;; &#125; handleClick(e) &#123; this.setState(&#123; liked: !this.state.liked &#125;); &#125; render() &#123; const text = this.state.liked ? 'like' : 'haven\'t liked'; return ( &lt;p onClick=&#123;this.handleClick.bind(this)&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125; 参数传递ES6写法：给事件处理函数传递额外参数的方式：bind(this, arg1, arg2, ...) 123456render: function() &#123; return &lt;p onClick=&#123;this.handleClick.bind(this, param1,param2,param3)&#125;&gt;;&#125;,handleClick: function(param1,param2,param3, event) &#123; // handle click&#125; React 支持的事件列表http://reactjs.cn/react/docs/events.html Dom操作 findDOMNode()方法（了解） 首先我们要了解 ReactDOM.render组件返回的是对组件的引用也就是组件实例（对于无状态状态组件来说返回 null），注意 JSX 返回的不是组件实例，它只是一个 ReactElement 对象。当组件加载到页面上之后（mounted），你都可以通过react-dom提供的findDOMNode()方法拿到组件对应的 DOM 元素。123456import &#123; findDOMNode &#125; from 'react-dom';// Inside Component classcomponentDidMound() &#123; const el = findDOMNode(this);&#125; findDOMNode() 不能用在无状态组件上。 方法二：refs属性另外一种方式就是通过在要引用的 DOM 元素上面设置一个 ref 属性指定一个名称，然后通过 this.refs.name 来访问对应的 DOM 元素。如果 ref 是设置在原生 HTML 元素上，它拿到的就是 DOM 元素，如果设置在自定义组件上，它拿到的就是组件实例，这时候就需要通过 findDOMNode 来拿到组件的 DOM 元素。因为无状态组件没有实例，所以 ref 不能设置在无状态组件上，一般来说这没什么问题，因为无状态组件没有实例方法，不需要 ref 去拿实例调用相关的方法，但是如果想要拿无状态组件的 DOM 元素的时候，就需要用一个状态组件封装一层，然后通过ref 和 findDOMNode去获取。 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from 'react';export default class MyInputFocus extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; userInput: '' &#125;; &#125; handleChange(e) &#123; console.log(this.refs.theInput.value); this.setState(&#123; userInput: e.target.value &#125;); &#125; clearAndFocusInput() &#123; this.setState(&#123; userInput: '' &#125;, () =&gt; &#123; this.refs.theInput.focus(); &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;div onClick=&#123;this.clearAndFocusInput.bind(this)&#125;&gt; Click to Focus and Reset &lt;/div&gt; &lt;input ref="theInput" value=&#123;this.state.userInput&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;MyInputFocus.defaultProps=&#123; autoPlay:false, maxLoops:10,&#125;MyInputFocus.propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired,&#125; 注意事项 你可以使用 ref 到的组件定义的任何公共方法，比如 this.refs.myTypeahead.reset() Refs 是访问到组件内部 DOM 节点唯一可靠的方法 Refs 会自动销毁对子组件的引用（当子组件删除时） 不要在 render 或者 render 之前访问 refs 不要滥用 refs，比如只是用它来按照传统的方式操作界面 UI：找到 DOM -&gt; 更新 DOM###组件的 DOM 事件监听这篇文章是讲如何给 DOM 元素绑定 React 未提供的事件1234567891011121314151617181920212223var Box = React.createClass(&#123; getInitialState: function() &#123; return &#123;windowWidth: window.innerWidth&#125;; &#125;, handleResize: function(e) &#123; this.setState(&#123;windowWidth: window.innerWidth&#125;); &#125;, componentDidMount: function() &#123; window.addEventListener('resize', this.handleResize); &#125;, componentWillUnmount: function() &#123; window.removeEventListener('resize', this.handleResize); &#125;, render: function() &#123; return &lt;div&gt;Current window width: &#123;this.state.windowWidth&#125;&lt;/div&gt;; &#125;&#125;);React.render(&lt;Box /&gt;, mountNode); http://reactjs.cn/react/tips/dom-event-listeners.html 注意添加dom事件的位置 在组件退出的时候，取消监听事件 ###数据获取http://facebook.github.io/react/tips/initial-ajax.html ###表单表单不同于其他 HTML 元素，因为它要响应用户的交互，显示不同的状态，所以在 React 里面会有点特殊。 状态属性 表单元素有这么几种属于状态的属性： value，对应&lt;input&gt; 和 &lt;textarea&gt; 所有 checked，对应类型为checkbox 和 radio 的&lt;input&gt; 所有 selected，对应 &lt;option&gt; 所有 在 HTML 中 &lt;textarea&gt; 的值可以由子节点（文本）赋值，但是在 React 中，要用 value 来设置。表单元素包含以上任意一种状态属性都支持 onChange 事件监听状态值的更改。针对这些状态属性不同的处理策略，表单元素在 React 里面有两种表现形式。 受控组件对于设置了上面提到的对应“状态属性“值的表单元素就是受控表单组件，比如 123render: function() &#123; return &lt;input type="text" value="hello"/&gt;;&#125; 一个受控的表单组件，它所有状态属性更改涉及 UI 的变更都由 React 来控制（状态属性绑定 UI）。比如上面代码里的&lt;input&gt;输入框，用户输入内容，用户输入的内容不会显示（输入框总是显示状态属性 value 的值 hello），这有点颠覆我们的认知了，所以说这是受控组件，不是原来默认的表单元素了。如果你希望输入的内容反馈到输入框，就要用 onChange 事件改变状态属性 value 的值：1234567891011121314getInitialState: function() &#123; return &#123;value: 'hello'&#125;;&#125;,handleChange: function(event) &#123; this.setState(&#123;value: event.target.value&#125;);&#125;,render: function() &#123; var value = this.state.value; return &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;;&#125;//使用这种模式非常容易实现类似对用户输入的验证，或者对用户交互做额外的处理，比如截断最多输入140个字符：handleChange: function(event) &#123; this.setState(&#123;value: event.target.value.substr(0, 140)&#125;);&#125; 非受控属性和受控组件相对，如果表单元素没有设置自己的“状态属性”，或者属性值设置为 null，这时候就是非受控组件。它的表现就符合普通的表单元素，正常响应用户的操作。同样，你也可以绑定 onChange 事件处理交互。如果你想要给“状态属性”设置默认值，就要用 React 提供的特殊属性 defaultValue，对于 checked 会有 defaultChecked，&lt;option&gt; 也是使用 defaultValue。 为什么要有受控组件引入受控组件不是说它有什么好处，而是因为 React 的 UI 渲染机制，对于表单元素不得不引入这一特殊的处理方式。在浏览器 DOM 里面是有区分 attribute 和property 的。attribute 是在 HTML 里指定的属性，而每个 HTML 元素在 JS 对应是一个 DOM 节点对象，这个对象拥有的属性就是 property（可以在 console 里展开一个 DOM 节点对象看一下，HTML attributes 只是对应其中的一部分属性），attribute 对应的 property 会从 attribute 拿到初始值，有些会有相同的名称，但是有些名称会不一样，比如 attribute class 对应的 property 就是 className。（详细解释：.prop，.prop()vs .attr()）回到 React 里的 &lt;input&gt; 输入框，当用户输入内容的时候，输入框的 value property会改变，但是 value attribute 依然会是 HTML 上指定的值（attribute 要用 setAttribute 去更改）。React 组件必须呈现这个组件的状态视图，这个视图 HTML 是由 render 生成，所以对于123render: function() &#123; return &lt;input type="text" value="hello"/&gt;;&#125; 在任意时刻，这个视图总是返回一个显示 hello 的输入框。 &lt;select&gt;的处理在 HTML 中 &lt;select&gt; 标签指定选中项都是通过对应 的 selected 属性来做的，但是在 React 修改成统一使用 value。所以没有一个 selected 的状态属性。 12345&lt;select value="B"&gt; &lt;option value="A"&gt;Apple&lt;/option&gt; &lt;option value="B"&gt;Banana&lt;/option&gt; &lt;option value="C"&gt;Cranberry&lt;/option&gt;&lt;/select&gt; 你可以通过传递一个数组指定多个选中项：&lt;select multiple={true} value={[&#39;B&#39;, &#39;C&#39;]}&gt; ###参数传递的判断http://facebook.github.io/react/docs/transferring-props.html ###组合组件使用组件的目的就是通过构建模块化的组件，相互组合组件最后组装成一个复杂的应用。在 React 组件中要包含其他组件作为子组件，只需要把组件当作一个 DOM 元素引入就可以了。 http://reactjs.cn/react/docs/multiple-components.html 循环插入子元素如果组件中包含通过循环插入的子元素，为了保证重新渲染 UI 的时候能够正确显示这些子元素，每个元素都需要通过一个特殊的 key 属性指定一个唯一值。为了内部 diff 的效率。123456789var TodoList = React.createClass(&#123; render: function() &#123; var createItem = function(item) &#123; return &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;; &#125;; return &lt;ul&gt;&#123;this.props.items.map(createItem)&#125;&lt;/ul&gt;; &#125;&#125;);module.export=TodoList 当 React 校正带有 key 的子级时，它会确保它们被重新排序（而不是破坏）或者删除（而不是重用）。 务必 把 key 添加到子级数组里组件本身上，而不是每个子级内部最外层 HTML 上。 也可以传递 object 来做有 key 的子级。object 的 key 会被当作每个组件的 key。但是一定要牢记 JavaScript 并不总是保证属性的顺序会被保留。实际情况下浏览器一般会保留属性的顺序，除了 使用 32位无符号数字做为 key 的属性。数字型属性会按大小排序并且排在其它属性前面。一旦发生这种情况，React 渲染组件的顺序就是混乱。可能在 key 前面加一个字符串前缀来避免：12345678910111213141516render: function() &#123; var items = &#123;&#125;; this.props.results.forEach(function(result) &#123; // 如果 result.id 看起来是一个数字（比如短哈希），那么 // 对象字面量的顺序就得不到保证。这种情况下，需要添加前缀 // 来确保 key 是字符串。 items['result-' + result.id] = &lt;li&gt;&#123;result.text&#125;&lt;/li&gt;; &#125;); return ( &lt;ol&gt; &#123;items&#125; &lt;/ol&gt; ); &#125; 子级组件标签里面包含的子元素会通过父元素的props.children 传递进来。HTML 元素会作为 React 组件对象、JS 表达式结果是一个文字节点，都会存入 Parent 组件的 props.children。props.children 通常是一个组件对象的数组，但是当只有一个子元素的时候，props.children将是这个唯一的子元素，而不是数组了 123456789101112131415161718192021var NotesList = React.createClass(&#123; render: function() &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取，运行结果如下。 这里需要注意， this.props.children的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。React 提供一个工具方法 React.Children 来处理 this.props.children。我们可以用 React.Children.map 来遍历子节点，而不用担心this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children的方法，请参考官方文档。 ###propsTypehttp://www.reactjs.cn/react/docs/reusable-components.html ###Contexthttp://facebook.github.io/react/docs/context.html ###动画http://facebook.github.io/react/docs/animation.htmlhttp://blog.csdn.net/lihongxun945/article/details/46778723https://zhuanlan.zhihu.com/p/20419592 ###获取react常用插件的网址https://js.coach/react/react-infinitehttps://react.parts/native ####diff算法http://blog.csdn.net/lihongxun945/article/details/46640503http://reactjs.cn/react/docs/reconciliation.htmlhttp://blog.csdn.net/yczz/article/details/49585283http://blog.csdn.net/yczz/article/details/49886061 ###Web Componentshttp://www.oschina.net/p/polymerhttp://facebook.github.io/react/docs/webcomponents.html ####服务器渲染http://zhuanlan.zhihu.com/p/20669111?from=groupmessage&amp;isappinstalled=0 ###组件间通信 非父子组件间的通信使用全局事件 Pub/Sub 模式，在 componentDidMount 里面订阅事件，在 componentWillUnmount 里面取消订阅，当收到事件触发的时候调用 setState 更新 UI。这种模式在复杂的系统里面可能会变得难以维护，所以看个人权衡是否将组件封装到大的组件，甚至整个页面或者应用就封装到一个组件。一般来说，对于比较复杂的应用，推荐使用类似 Flux 这种单项数据流架构，参见Data Flow。Flux和redux 数据流FluxGithub地址：https://github.com/facebook/flux React redux react-redux react-router webpack+gulp ES6 babel Mocha+chai node React native Flex fetch 原生 找插件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[angular常见问题解答]]></title>
      <url>%2F2017%2F04%2F11%2Fangular-bug%2F</url>
      <content type="text"><![CDATA[angular常见问题解答 angularjs 是mvc还是mvvm框架 首先阐述下你对mvc和mvvm的理解 首先为什么我们会需要MVC？因为随着代码规模越来越大，切分职责是大势所趋，还有为了后期维护方便，修改一块功能不影响其他功能。还有为了复用，因为很多逻辑是一样的。而MVC只是手段，终极目标是模块化和复用。 mvvm的优点 低耦合：View可以独立于Model变化和修改，同一个ViewModel可以被多个View复用；并且可以做到View和Model的变化互不影响； 可重用性：可以把一些视图的逻辑放在ViewModel，让多个View复用； 独立开发：开发人员可以专注与业务逻辑和数据的开发（ViewModemvvmdi计人员可以专注于UI(View)的设计； 可测试性：清晰的View分层，使得针对表现层业务逻辑的测试更容易，更简单。 在angular中MVVM模式主要分为四部分： * View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。 * ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色 * Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。 * Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。 mvc的界面和逻辑关联紧密，数据直接从数据库读取。mvvm的界面与viewmode是松耦合，界面数据从viewmodel中获取。所以angularjs更倾向于mvvm angularjs中$scope，controller，directive，sevice在mvvm中充当什么角色 如果你不知道，第一题的分析以及很明确，仔细再仔细的看一遍 在使用angularjs项目开发中 你使用过那些第三方的插件AngularUi ui-router oclazyload等等 附上一篇文章仔细去看看 https://segmentfault.com/a/1190000003858219 在angular项目中你如何控制静态资源的合理加载第三题提到了oclazyload这个插件，很好的一个懒加载静态资源的第三方插件 再写controlloer逻辑的时候 你需要注意什么？ 简化代码（这个是所有开发人员都要具备的） 坚决不能操作dom节点 这个时候可能会问 为什么不能啊你的回答是：DOM操作只能出现在指令（directive）中。最不应该出现的位置就是服务（service）中。Angular倡导以测试驱动开发，在service或者controller中出现了DOM操作，那么也就意味着的测试是无法通过的。当然，这只是一点，重要的是使用Angular的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑，无需关系一堆堆的DOM操作。如果在Angular的代码中还到处充斥着各种DOM操作，那为什么不直接使用jquery去开发呢。 测试驱动开发是什么呢？普及一下：测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。 AngularJS的数据双向绑定是怎么实现的？1、每个双向绑定的元素都有一个watcher2、在某些事件发生的时候，调用digest脏数据检测。这些事件有：表单元素内容变化、Ajax请求响应、点击按钮执行的函数等。3、脏数据检测会检测rootscope下所有被watcher的元素。$digest函数就是脏数据监测又附上一篇原理性的文章 https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md controller之间怎么通讯 event这里可以有两种方式，一种是$scope.$emit，然后通过监听$rootScope的事件获取参数；另一种是$rootScope.$broadcast，通过监听$scope的事件获取参数。这两种方法在最新版本的Angular中已经没有性能区别了，主要就是事件发送的方向不同，可以按实际情况选择。 service可以创建一个专用的事件Service，也可以按照业务逻辑切分，将数据存储在相应的Service $rootScope这个方法可能会比较dirty一点，胜在方便，也就是把数据存在$rootScope中，这样各个子$scope都可以调用，不过需要注意一下生命周期 直接使用$scope.$$nextSibling及类似的属性类似的还有$scope.$parent。这个方法的缺点就更多了，官方不推荐使用任何$$开头的属性，既增加了耦合，又需要处理异步的问题，而且scope的顺序也不是固定的。不推荐另外就是通过本地存储、全局变量或者现代浏览器的postMessage来传递参数了，除非特殊情况，请避免这类方式。 自定义指令的几个参数说几个常用的如：restrict:指令在dom中的声明形式 E（元素）A（属性）C（类名）M（注释）template：两种形式，一种HTML文本；一个可以接受两个参数的函数，tElemetn和tAttrs，并返回一个代表模板的字符串。模板字符串必须存在一个根DOM元素templateUrl:两种形式，一种代表外部HTML文件路径的字符串；一个可以接受两个参数的函数，参数为tElement和tAttrs，并返回一个外部HTML文件路径的字符串compile (对象或函数)：compile 选项可以返回一个对象或函数。如果设置了 compile 函数,说明我们希望在指令和实时数据被放到DOM中之前进行DOM操作,在这个函数中进行诸如添加和删除节点等DOM操作是安全的。本质上,当我们设置了 link 选项,实际上是创建了一个 postLink() 链接函数,以便 compile() 函数可以定义链接函数。然后又是传送门：http://www.cnblogs.com/mliudong/p/4180680.htmlcompile和link的区别：编译的时候，compile转换dom，碰到绑定监听器的地方就先存着，有几个存几个，到最后汇总成一个link函数，一并执行，提升了性能。 angular中的$http$http 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。我们可以使用内置的$http服务直接同外部进行通信。$http服务只是简单的封装了浏览器原生的XMLHttpRequest对象1、链式调用$http服务是只能接受一个参数的函数，这个参数是一个对象，包含了用来生成HTTP请求的配置内容。这个函数返回一个promise对象，具有success和error两个方法。2、返回一个promise对象3、快捷的get请求4、响应对象传送门：https://github.com/facebook/flux angular和jquery的区别angular是基于数据驱动，所以angular适合做数据操作比较繁琐的项目（这里可以再提一下单页面应用，如果你不会福利又来了 http://www.zhihu.com/question/20792064）jquery是基于dom驱动，jquery适合做dom操作多的项目 对angular中的form表单了解多少Angular对input元素的type进行了扩展，一共提供了以下10种类型：textnumberurlemailradiocheckboxhiddenbuttonsubmitresetAngular为表单内置了4中CSS样式。ng-valid 校验合法状态ng-invalid 校验非法状态ng-pristine 如果要使用原生的form，需要设置这个值ng-dirty 表单处于脏数据状态Angular在对表单进行自动校验的时候会校验Model上的属性，如果不设置ng-model，则Angular无法知道myForm.$invalid这个值是否为真。校验的一下内容required 表示是否输入内容ng-maxlength 最大长度ng-minlength 最小长度例子：传送门https://github.com/18500047564/clutter ng-show/ng-hide 与 ng-if 的区别？我们都知道ng-show/ng-hide实际上是通过 display 来进行隐藏和显示的。而ng-if实际上控制dom节点的增删除来实现的。因此如果我们是根据不同的条件来进行dom节点的加载确认的话，那么ng-if的性能好过ng-show. 解释下什么是 $rootScrope 以及和 $scope 的区别？$rootScrope是所有$scope的父对象 表达式 {{yourModel}}是如何工作的？ 它依赖于 $interpolation服务，在初始化页面html后，它会找到这些表达式，并且进行标记，于是每遇见一个{{ } } ，则会设置一个 $watch 。而 $interpolation 会返回一个带有上下文参数的函数，最后该函数执行，则算是表达式 $parse 到那个作用域上。 fliter是什么你了解的有多少？实现一个自定义fliterng 内置的 filter 有九种：date（日期）currency（货币）limitTo（限制数组或字符串长度）orderBy（排序）lowercase（小写）uppercase（大写）number（格式化数字，加上千位分隔符，并接收参数限定小数点位数）filter（处理一个数组，过滤出含有某个子串的元素）json（格式化 json 对象）filter 有两种使用方法，一种是直接在页面里：&lt;p&gt;{{now | date : ‘yyyy-MM-dd’}}`&lt;/p&gt;另一种是在 js 里面用：$filter(‘过滤器名称’)(需要过滤的对象, 参数1, 参数2,…)$filter(‘date’)(now, ‘yyyy-MM-dd hh:mm:ss’);自定义一个去重数组的:123456789101112131415app.filter('unique', function()&#123; return function(arr)&#123; var n = []; var obj = &#123;&#125;; for(var i = 0;i&lt;arr.length;i++)&#123; if(!obj[arr[i]])&#123; n.push(arr[i]) obj[arr[i]] = 1; &#125; &#125; return n; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五分钟学会Seajs]]></title>
      <url>%2F2017%2F04%2F11%2Fseajs%2F</url>
      <content type="text"><![CDATA[1：引入包文件 sea.js 2: 启动seajs.use(‘./main’) 设置启动入口模块 参数可以不需要.js后缀 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;06_seajs基本使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1：引包 --&gt; &lt;script src="../seajs-3.0.0/dist/sea.js" charset="utf-8"&gt;&lt;/script&gt; &lt;!-- &lt;script src="./one.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="./two.js" charset="utf-8"&gt;&lt;/script&gt; 不适用seajs加载的方式，需要注意文件顺序--&gt; &lt;!-- 2: 启动seajs 并且指定入口模块 --&gt; &lt;script type="text/javascript"&gt; seajs.use('./one'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3: 声明一个模块：模块在define();内部包裹 4: 需要向外暴露值，通过module.exports来返回 12345define(function(require,exports,module)&#123; // 如果这个模块需要别的模块的返回值 var aaa =require('模块路径ID');//返回对方模块内部的module.exports module.exports = 返回值;&#125;); 在模块内部，声明的变量，都是模块的作用域+ 在CMD中，一个模块就是一个文件，外部无法访问 + 如果需要访问，通过module.exports 向外暴露 define参数的三种方式 字符串 define(‘123’) define(‘我是字符串’); 对象define({name:’aaa’}) define({name:’gaga’,age:19}); 函数define(function(require,exports,module){}) 1234define(function(require,exports,module)&#123; // module.exports = &#123;nane:'jack'&#125; return 'abcl';&#125;) exports和module.exports的小问题 模块被加载的时期，这两个对象都指向一块内存，该内存初始值是一个空对象 不管任意改变哪个对象的内存指向 （对象=值），最终仍然返回module.exports对象 如果module.exports 和exports让你头晕脑胀，建议使用module.exports 框架的使用尽量遵守其规则,基于define内部解析对象，根据参数的数据来，顺序不要改变 module.exports 用来赋值并暴露，exports用来给暴露的对象挂载属性，就是一个简写Use的2种方法 use函数是一个异步函数 异步：不阻塞后续代码执行 同步：当前函数不执行完毕，下一行代码无法执行1234567seajs.use('./a',function(a)&#123; code.... &#125;) // 着重掌握 seajs.use(['./a','./b'],function(a,b)&#123; code.. &#125;) seajs.use 第二个参数是一个函数，内部参数与传入的加载模块的返回值的顺序一致 总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[requireJS学习]]></title>
      <url>%2F2017%2F04%2F11%2Frequirejs%2F</url>
      <content type="text"><![CDATA[requireJS requireJS也可以用Seajs写法,不建议，因为思想冲突，代码风格不再是加载前置了 1: 引包 2：开启程序入口模块 requirejs([‘./a’,’./b’],function(a,b){code..}) seajs.use([‘./a’,’./b’],function(a,b){code..}); 3: 定义一个模块 define(依赖项数组,返回值的回调); define(function(require,exports,module){code..}); 4: 向外暴露 return seajs: module.exports || exports 挂载属性 5: 需要拿到别的模块的暴露值，参考第三点中的返回值回调 seajs：requireseajs和 requireJS比较 requireJS加载前置，声明前置 （需要什么提前准备好） 首先加载文件前,检查该文件是否有依赖，如果有依赖，先加载依赖模块，再加载本身模块. seajs加载：懒加载，延迟加载，加载滞后（什么时候，什么时候加载） 玉伯：seajs:明显没有bug —— requirejs: 没有明显的bug 我个人认为requireJS可能用得比较多一点 requirejs加载机制,思想更贴合前端开发引入标签的模式 加载的机制，在web端，可能因为网络或者卡顿，不太会出现出来一部分，另一部分白的 懒加载思想就是节省资源 ####图解seajs和 requireJS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块化规范]]></title>
      <url>%2F2017%2F04%2F11%2Fcommonjs%2F</url>
      <content type="text"><![CDATA[服务器端规范 CommonJS Node.js CommonJS 定义JavaScript语言后端规范 后端语言应该具备什么能力？ 接收请求、处理底层数据、 模块化定义（Module) 浏览器端规范 AMD RequireJS AMD 也是一种规范的名称，推崇异步加载，遵循依赖前置(加载前置)(提前加载) CMD Seajs CMD是一种规范 推崇同步加载 遵循加载滞后，按需加载,懒加载(需要的时候加载)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript 数组]]></title>
      <url>%2F2017%2F04%2F10%2F0901-javascript%2F</url>
      <content type="text"><![CDATA[javascript 数组定义数组一维数组创建语法： var 数组名称 = new Array([size]);[size] 表示数组中可存放的元素总数或值([ 该选项可选可不选]) 方法1 12345var fruit = new Array( );fruit[0]=“apple”fruit[1]=“orange”fruit[2]=“peach”fruit[3]="bananer" 方法2 var fruit= new Array(&quot;apple&quot;, &quot;orange&quot;, &quot; peach&quot;,&quot;bananer&quot;) //指定数组长度，数组元素赋值 方法3 指定长度小于数组元素实际数量 制定长度大于数组元素实际数量 方法四：推荐使用 12var arr4 = [false,"aaa",123];alert(arr4);//false,aaa,123 数组内可以存放任意类型的数据 数组元素丌赋值，则为undefined 打印数组时，如果某个元素没有赋值，则为“” 访问数组范围以外的元素时，丌会出现越界异常，为undefined 定义的数组大小，依然可以添加更多的元素 二维数组创建语法： 语法1: var arr = new Array([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],[&#39;d&#39;,&#39;e&#39;]); arr[0]返回第一个一维数组，arr[0][0]返回第一个一维数组的第一个元素‘ a’ 二维数组可以理解为一个存放数据内容为一维数组的一维数组 二维数组创建语法： 语法二: 12345678 var arr = new Array();arr[0]= new Array();arr[0][0]= “a”;arr[0][1]= “b”;arr[0][2]= “c”;arr[1]= new Array();arr[1][0]= “c”;arr[1][1]= “d”; javascript的数组丌需要设定长度，会自己迚行扩展 访问数组 访问数组代码： 一维数组：document.write(fruit[0]); 输出：apple 二维数组：document.write(arr[0][0]); 输出：a 修改已有数组中的值123fruit[0]=“pear”document.write(fruit[0])输出：pear 数组的便利 利用for语句访问数组中的元素值 12345678910111213141516方法一：var arr = newArray(13.5,3,4,5,6);for(var i=0;i&lt;arr.length;i++)&#123;alert(arr[i])&#125;方法二：方法二：var xvar mycars = new Array()mycars[0] = "Saab"mycars[1] = "Volvo"mycars[2] = "BMW"for (x in mycars)&#123;document.write(mycars[x])&#125; 数组的常用属性和方法 数组常用属性—length属性 数组属性length 设置或返回数组中元素的数目，该属性的值始终从数值上大于所属数组的任何一个索引号 修改数组的length对数组索引的影响 手动增大length属性丌影响索引 手动减少length属性会截掉多余的索引 修改索引对length属性的影响 增大数组最大索引号会增大length属性 删除索引号最大的索引属性丌会影响length属性 ###数组常用的方法： 数组方法 join( ) ：把数组的所有元素放入一个字符串，通过一个的分隔符迚行分隔 pop( )：删除并返回数组的最后一个元素 push( )：向数组的末尾添加一个戒更多元素，并返回新的长度 shift()：删除并返回数组的第一个元素 unshift()：向数组的开头添加一个戒更多元素，并返回新的长度数组的常用属性和方法 reverse()：颠倒数组中元素的顺序 sort( )：对数组的元素迚行排序 concat():连接两个戒更多的数组，并返回结果。 slice():从某个已有的数组返回选定的元素 splice():删除元素，并向数组添加新元素多维数组 数组分为一维数组和多维数组二维数组及以上的都称为多维数组，上面我们讲解了一维数组，下面我们例举一下多维数组，以二维数组为例。 12345[["Name0", "Age0", "Address0"],["Name1", "Age1", "Address1"],["Name2", "Age2", "Address2"]] 二维数组的创建： 123456789Var personnel = new Array();Personnel[0]= new Array();Personnel[0][0]= “Name0”;Personnel[0][1]= “Age0”;Personnel[0][2]= “Address0”;Personnel[1]= new Array();Personnel[1][0]= “Name1”;Personnel[1][1]= “Age1”;Personnel[1][2]= “Address1”; 12345678910//方法2Var aa=new Array(); //定义一维数组for(i=1;i&lt;=10;i++)&#123; aa[i]=new Array(); //将每一个子元素又定义为数组for(n=0;n&lt;=10;n++)&#123;aa[i][n]=i+n; //此时aa[i][n]可以看作是一个二维数 组&#125;&#125; 还可创建三维数组，四维五维甚至一百维的，但是维数越多越复杂，超过二维的很少使用，下面演示了一个五维数组的声明和访问： 1234567var myArray=new Array();myArray[0]=new Array();myArray[0][0]=new Array();myArray[0][0][0]=new Array();myArray[0][0][0][0]=new Array(); myArray[0][0][0][0][0]=“This is getting out of hand”Document.write(myArray[0][0][0][0][0]); 数组的排序 sort()方法是按照字符编码的顺序进行排序 12345678910111213function sortNumber(a,b)&#123;return a - b&#125;var arr = new Array(6)arr[0] = "10"arr[1] = "5"arr[2] = "40"arr[3] = "25"arr[4] = "1000"arr[5] = "1"document.write(arr + "&lt;br /&gt;")document.write(arr.sort(sortNumber)) 输出10,5,40,25,1000,1 1,5,10,25,40,1000 冒泡排序 123456789101112131415//冒泡排序法一:function sort(elements)&#123;for(var i=0;i&lt;elements.length-1;i++)&#123;for(var j=0;j&lt;elements.length-i-1;j++)&#123;if(elements[j]&gt;elements[j+1])&#123;var swap=elements[j];elements[j]=elements[j+1];elements[j+1]=swap;&#125; &#125;&#125;&#125;var elements = [3, 1, 5, 7, 2, 10, 8, 9, 4, 6];document.write('before: ' +elements+"&lt;br/&gt;");sort(elements);document.write(' after: ' + elements); &gt; 输出：before: 3,1,5,7,2,10,8,9,4, after: 1,2,3,4,5,6,7,8,9,10 123456789101112131415function bubbleSort(arr) &#123;var i = arr.length, j;var tempExchangVal;while (i &gt; 0) &#123; for (j = 0; j &lt; i - 1; j++) &#123;if (arr[j] &gt; arr[j + 1]) &#123;tempExchangVal = arr[j]; arr[j] = arr[j + 1];arr[j + 1] = tempExchangVal;&#125;&#125;i--;&#125;return arr;&#125; 城市二级联动:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;select id="gametype"&gt; &lt;option value="aa"&gt;游戏分类&lt;/option&gt;&lt;/select&gt;&lt;/br&gt; &lt;/br&gt;&lt;/br&gt;&lt;select id="gamelist"&gt; &lt;option&gt;游戏名称&lt;/option&gt;&lt;/select&gt;&lt;script&gt; window.onload=function () &#123; var game = new Array( ); game['纸牌游戏']=['斗地主', '拖拉机', '桥牌', '拱猪', '打百分']; game['棋类游戏']=['军棋', '跳棋', '五子棋', '围棋', '中国象棋', '国际象棋', '飞行棋', '黑白棋']; game['其他游戏'] = ['连连看', '俄罗斯方块', '麻将', '台球', '挑错']; // var gametype=document.getElementById("gametype") for(var x in game)&#123; gametype.add(new Option(x,x)) &#125; gametype.onchange=function () &#123; var gamelist=document.getElementById("gamelist") gamelist.options.length=0; var gametypevalue=gametype.value; for(var j in game)&#123; if(j==gametypevalue)&#123; for(var f=0;f&lt;game[j].length;f++)&#123; console.log(game[j]); console.log(game[j][f]); gamelist.add(new Option(game[j][f],game[j][f])) &#125; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS赋值 运算比较 流程控制]]></title>
      <url>%2F2017%2F04%2F10%2F0801-javascript%2F</url>
      <content type="text"><![CDATA[JS赋值 运算比较 流程控制变量的声明与赋值 先声明变量再赋值 var width width=5var － 用于声明变量的关键字width － 变量名 同时声明和赋值变量 var catName= “ 皮皮”; var x, y, z = 10; 不声明直接赋值 width=5 JS运算运算符号 算数运算符(+,-,*,/,%,++,–) 赋值运算符(=,+=,-=,*=,/=,%=) 字符串连接符(+) 优先级: 优先级：（）&gt;算术运算符（先乘除后加减）&gt;赋值运算符 JS比较比较符号 比较运算符(&gt;,&lt;,&gt;=,&lt;=,==,===,!=,!==) 逻辑运算符(&amp;&amp;,||,!) 三目运算符: 条件?语句1:语句2 JS 流程控制简介: 所谓的“流程”就是程序代码执行的顺序。在任何一种语言中，程序控制是必需的。它能使整个程序减少混乱，使之顺利按照其一定的方式执行。 JavaScript常用的控制流程有3种基本结构：顺序结构、选择结构、循环结构顺序结构,正常情况下，程序中的语句是按照书写顺序执行的，这种结构成为顺序结构。前面所例丼的程序都是顺序结构的程序。 选择结构 选择结构主要用判断语句来实现根据一定的条件决定进一步执行那些语句。 JavaScript提供了两种类型的选择结果语句，也成为判断语句：if语句和switch语句。一般来讲if语句用于从两条执行路线中选择其一执行,而switch语句用于从多条执行路线中选择其一执行。 if语句 123if(条件)&#123;//JavaScript代码;&#125; If条件语句 12345if(条件)&#123;//JavaScript代码;&#125;else&#123;//JavaScript代码;&#125; If…else if…else语句 123456789101112if (条件 1)&#123;当条件 1 为 true 时执行的代码&#125;else if (条件 2)&#123;当条件 2 为 true 时执行的代码&#125;else&#123;当条件 1 和 条件 2 都不为 true 时执行的代码&#125; switch语句 12345678910switch(n)&#123; case 1:执行代码块 1break;case 2:执行代码块 2break;default:n 与 case 1 和 case 2 不同时执行的代码&#125; 循环结构 前面介绍的if语句和switch语句，都属于条件判断语句。即在条件为真的情况下每行脚本只有一次执行的机会。对于实际情况中，需要根据条件或计数器来重复执行多行程序代码的能力，利用循环语句来实现。在JavaScript中有两种主要类型的循环语句，for循环和while循环 for 循环 1234for (语句 1; 语句 2; 语句 3)&#123;被执行的代码块&#125; 语句 1 在循环（代码块）开始前执行 语句 2 定义运行循环（代码块）的条件 语句 3 在循环（代码块）已被执行之后执行 While 语句 1234while (条件)&#123;需要执行的代码&#125; Do…While语句 12345do&#123;需要执行的代码&#125;while (条件); 在循环语句中，只有当循环条件表达式值为false时，循环语句才能结束，为了给for和while循环加入更多的使用程序，JavaScript包含有break和continue语句。这两个语句可用于改变循环的流程。 Break语句 中断循环 Continue语句 开始下一次循环]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript基本对象,数据类型,常量,变量]]></title>
      <url>%2F2017%2F04%2F10%2F07-01-javascript%2F</url>
      <content type="text"><![CDATA[javascript基本对象,数据类型,常量,变量javascript数据类型 基本数据类型 Number String Boolean Null Undefined 混合数据类型 Object js中变量是松散类型的，因此有时我们需要检测变量的数据类型 typeof操作符可以检测变量的数据类型（输出的是一个关于数据类型的字符串） 数字(Number) 介绍Number类型包含整数和浮点数（浮点数数值必须包含一个小数点，且小数点后面至少有一位数字）两种值 例如:var x1=34.00; //使用小数点来写var x2=34; //不使用小数点来写 极大或极小的数字可以通过科学（指数）计数法来书写： 例：var y=123e5; // 12300000var z=123e-5; // 0.00123 NaN:非数字类型 特点：涉及到的 任何关于NaN的操作，都会返回NaN NaN不等于自身。 例：var ab = &quot;a1&quot;;console.log(ab/10);// NaNconsole.log(NaN == NaN);// false; ###字符串（string） 例：var carname=&quot;Bill Gates&quot;;var answer=&quot;He is called &#39;Johnny&#39;&quot;; 字符串是存储字符（比如 “Bill Gates”）的变量。 字符串可以是引号中的任意文本，可以使用单引号或双引号，只要不匹配包围字符串的引号即可 注： JavaScript对大小写敏感 ###布尔（boolean） 例：var x=truevar y=false 布尔（逻辑）只能有两个值：true 或 false。 Undefined Undefined 这个值表示变量不含有值。* 可以通过将变量的值设置为 null 来清空变量 null null类型被看做空对象指针，null类型也是空的对象引用。只有一个值，即null值，所以，在用typeof 操作符去检测null类型的值时，结果是object类型。如果你定义了一个变量，但是想在以后把这个变量当做一个对象来用，那么最好将该对象初始化为null值 ###对象（object） 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： 例：var person={firstname : “Bill”,lastname : “Gates“}; 数组为混合数据类型中的一种 常量Constant：不变的值 const constantName = value1； 常量名首字符为字母或下划线，其后可有数字。 value1为直接量或表达式。 1个const关键字可定义1个或多个常量。 内置常量：JS中Infinity表无穷大的数值，-indinity表无穷小.NaN表非数值。 例：const a = 10; alert(a) ##变量 概念:变量是存取数字、提供存放信息的容器。对于变量，必须明确变量的命名、变量的类型、变量的声明及其变量的作用域。命名规范 变量命名规范: 变量必须以字母或下划线开头，后可以跟字母、数字、下划线，不能有空格或特殊字符等。 不用使用Javascript中的关键字作为变量，如var,true,double等。 在对变量命名时，最好把变量的意义与其代表的意思对应起来，以免发现错误。 变量的类型： 整数变量：x=100; 字符串变量：y=“125” 布尔型变量：xy=True 实型变量：cost=19.5 变量的声明 JavaScript可以在使用前先声明，并可赋值。变量声明用可用命令var; 例：var mytest;该例子定义了一个mytest变量，但没有赋予其值例：var mytest=“This is a book”该例子定义了变量并为其赋予了值。 变量的作用域： 变量分为全局变量和局部变量。 全局变量是定义在所有函数体乊外，其作用范围是整个函数 局部变量是定义在函数体乊内，只对其该函数是可见的，而对其它函数则是不可见的。 函数体内可以访问父级函数的变量，父级函数不能访问子函数的变量。注：在声明变量时凡是没有var关键字，而直接赋值的变量均为全局变量 ## JavaScript 的基本对象 对象包括：系统标准类对象 和 自定义对象 标准类对象: 字符串对象String、 日期对象Date、 数组对象Array、 数字对象Number 、 数学对象Math、 正则表达式对象RegExp *自定义类对象:自定义的包含属性和方法的对象 例：var person={ firstname : "Bill", lastname : "Gates", eat : function(){} };]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础引入]]></title>
      <url>%2F2017%2F04%2F10%2F06-01-javascript%2F</url>
      <content type="text"><![CDATA[javascript基础简介 轻量级、直译式客户端脚本语言。 可被所有浏览器执行，实现网页的劢态功能。 揑入 HTML 页面后，可由所有的现代浏览器执行应用场景 操作页面元素，动态改变页面内容动态改变表格内容 编写页面动态效果轮播图层的切换 和 树形菜单等 数据的客户端验证－减轻服务器端压力注册表单验证 通过ajax和后端语言实现数据交互 组成: ECMAScript BOM DOM ECMAScript 概念：JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言（比如JS）是什么样子。 编码遵循ECMAScript标准 BOM(浏览器对象模型) 概念:BOM是用于描述这种对象不对象乊间层次关系的模型，浏览器对象模型提供了独立于内容的、可以不浏览器窗口进行互劢的对象结构。 BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 DOM(文档对象模型) 概念:W3C组织推荐的处理可扩展置标语言的标准编程接口。 DOM是以面向对象方式描述的文档模型。 DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象乊间的关系。可以把DOM认为是页面上数据和结构的一个树形表示，丌过页面当然可能并丌是以这种树的方式具体实现。 ##javascript 使用方法 html内嵌javascript代码 &lt;script type=&quot;text/javascript&quot;&gt; //JavaScript 语句&lt;/script &gt; 外部JS文件 &lt;script src=&quot;hello.js&quot; language=&quot;javascript&quot;&gt;&lt;/script&gt; 行内编写方式 &lt;input name=&quot;btn&quot; type=&quot;button&quot; value=&quot;弹出消息框&quot;onclick=&quot;javascript:alert(&#39;欢迎你&#39;);&quot;/&gt; 事件监听 onload事件:是在页面或图片加载完成后立即执行的事件获取元素 getElementById()：获取指定 ID 的第一个对象引用 getElementsByName()：通过NAME属性获Document中指定名称对象的集合 getElementsByTagName()：使用指定的标签名返回所有的元素，这些元素是您在使用此方法时所处的元素的后代 JavaScript 的调试工具及调试方法 调试工具:Firebug工具 安装：火狐浏览器 - 选顷 – 附加组件 – 搜索Firebug添加即可。安装完成，按键盘f12即可打开Firebug Chrome和ie自带调试工具，不需要安装 调试方法 使用Firebug的HTML 、 CSS、脚本顷查看页面的html标签、 CSS文件、 JS文件。 Firebug控制台: 如果页面报错，会在控制台显示：包括错误原因和行号 控制台最下边的输入框可以输入js代码，提交浏览器执行 利用js的console方法，可以在控制台输出js代码中的值、对象、 DOM等，以方便查看对象的结构常用方法：console.log() console.dir()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[金立手机页面完成]]></title>
      <url>%2F2017%2F04%2F10%2F0501-prodoctlist%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[金立手机页面导航+banner]]></title>
      <url>%2F2017%2F04%2F10%2F0401-css%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[css 定位 浮动]]></title>
      <url>%2F2017%2F04%2F10%2F0301-css%2F</url>
      <content type="text"><![CDATA[css 定位 浮动定位 概念 :CSS 为定位和浮动提供了一些属性，利用这些属性，可以建立列式布局，将布局的一部分与另一部分重叠，还可以完成多年来通常需要使用多个表格才能完成的任务。 position属性: static:没有特别的设定，遵循基本的定位规定，不能通过z-index进行层次分级 relative:不脱离文档流，参考自身静态位置通过top,bottom,left,right定位，并且可以通过z-index进行层次分级 absolute:脱离文档流，通过top,bottom,left,right定位。选取其最近的父级定位元素，当父级position为static时，absolute元素将以body坐标原点进行定位，可以通过z-index进行层次分级。 fixed:这里他所固定的对像是可视窗口而并非是body或是父级元素。可通过z-index进行层次分级。 relative 相对定位 概念理论:相对定位是一个非常容易掌握的概念。如果对一个元素进行相对定位，它将出现在它自身所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 #box_relative{ position:relative;left:30px;top:20px; } 将在原位置顶部下面20 像素的地方，元素向右移动 30像素。 绝对定位（ absolute) 概念理论:绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 固定定位（ fixed） 概念理论:这里他所固定的对像是可视窗口而并非是body或是父级元素。 ###定位的层叠分级： z-index:auto|namber; auto遵从其父对象的定位 namber无单位的整数值。可为负数 浮动 float浮动 属性: float:left|right 影响: 脱离常规文档流而表现为向右或向左浮动(默认的常规文档流：页面内容从上到下，从左到右排列。 DIV块换行显示) 浮动的三大显著特点: DIV块元素失去“块状”换行显示特征，变为行内块元素 紧贴上一个浮动元素（同方向）或父级元素的边框，如宽度不够将换行显示 占据行内元素的空间，导致行内元素围绕显示 注意: 让块级元素在一行上显示，就使用浮动！ 如果是要实现模式转换，推荐使用display。 清楚浮动:clear clear的作用: 如果前一个元素存在左浮动或右浮动，则换行以区隔 只对块级元素有效 clear属性的取值:right|leftboth|none ##清除浮动推荐方法:&gt;1234567891011.clearfix:after&#123; content: &quot;&quot;; height: 0; line-height: 0; display: block; clear: both; visibility: hidden;&#125;.clearfix&#123; zoom: 1;&#125; ##清除浮动的八种方法: 父级div定义 height &gt;&lt;style type=&quot;text/css&quot;&gt; .div1{background:#000020;border:1px solid red;/* 解决代码 */height:200px;} .div2{background:#202020;border:1px solid red;height:100px;margin-top:10px} .left{float:left;width:20%;height:200px;background:#DDD} .right{float:right;width:30%;height:80px;background:#DDD}&lt;/style&gt;&lt;div class=&quot;div1&quot;&gt;&lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;div2&lt;/div&gt; * 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 * 优点：简单、代码少、容易掌握。 * 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题。 * 建议：不推荐使用，只建议高度固定的布局时使用。 结尾处加空div标签 clear:both &gt;&lt;style type=&quot;text/css&quot;&gt; .div1{background:#000020;border:1px solid red} .div2{background:#202020;border:1px solid red;height:100px;margin-top:10px} .left{float:left;width:20%;height:200px;background:#DDD} .right{float:right;width:30%;height:80px;background:#DDD} /* 清除浮动代码 */ .clearfloat{clear:both}&lt;/style&gt;&lt;div class=&quot;div1&quot;&gt;&lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;&lt;div class=&quot;clearfloat&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;div2&lt;/div&gt; * 原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度。 * 优点：简单、代码少、浏览器支持好、不容易出现怪问题。 * 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好。 * 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法。 父级div定义 伪类:after 和 zoom&gt; .div1{background:#000020;border:1px solid red;} .div2{background:#202020;border:1px solid red;height:100px;margin-top:10px} .left{float:left;width:20%;height:200px;background:#DDD} .right{float:right;width:30%;height:80px;background:#DDD} /*清除浮动代码*/ .clearfloat:after{display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0} .clearfloat{zoom:1} Left Right div2 原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题。 优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）。 缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 建议：推荐使用，建议定义公共类，以减少CSS代码。 父级div定义 overflow:hidden&gt; .div1{background:#000020;border:1px solid red;/*解决代码*/width:98%;overflow:hidden} .div2{background:#202020;border:1px solid red;height:100px;margin-top:10px;width:98%} .left{float:left;width:20%;height:200px;background:#DDD} .right{float:right;width:30%;height:80px;background:#DDD} Left Right div2 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度。 优点：简单、代码少、浏览器支持好。 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。 父级div定义 overflow:auto&gt; .div1{background:#000020;border:1px solid red;/*解决代码*/width:98%;overflow:auto} .div2{background:#202020;border:1px solid red;height:100px;margin-top:10px;width:98%} .left{float:left;width:20%;height:200px;background:#DDD} .right{float:right;width:30%;height:80px;background:#DDD} &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; div2 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度。 优点：简单、代码少、浏览器支持好。 缺点：内部宽高超过父级div时，会出现滚动条。 建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 * 父级div 也一起浮动 &gt; .div1{background:#000020;border:1px solid red;/解决代码/width:98%;margin-bottom:10px;float:left} .div2{background:#202020;border:1px solid red;height:100px;width:98%;/解决代码/clear:both} .left{float:left;width:20%;height:200px;background:#DDD} .right{float:right;width:30%;height:80px;background:#DDD} Left Right div2 原理：所有代码一起浮动，就变成了一个整体。 优点：没有优点。 缺点：会产生新的浮动问题。 建议：不推荐使用，只作了解。 父级div定义 display:table &gt; .div1{background:#000020;border:1px solid red;/解决代码/width:98%;display:table;margin-bottom:10px;} .div2{background:#202020;border:1px solid red;height:100px;width:98%;} .left{float:left;width:20%;height:200px;background:#DDD} .right{float:right;width:30%;height:80px;background:#DDD} Left Right div2 原理：将div属性变成表格。 优点：没有优点。 缺点：会产生新的未知问题。 建议：不推荐使用，只作了解。 结尾处加 br标签 clear:both&gt; .div1{background:#000020;border:1px solid red;margin-bottom:10px;zoom:1} .div2{background:#202020;border:1px solid red;height:100px} .left{float:left;width:20%;height:200px;background:#DDD} .right{float:right;width:30%;height:80px;background:#DDD} .clearfloat{clear:both} Left Right div2 原理：父级div定义zoom:1来解决IE浮动问题，结尾处加 br标签 clear:both。 建议：不推荐使用，只作了解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css从零开始]]></title>
      <url>%2F2017%2F04%2F10%2F0201-css%2F</url>
      <content type="text"><![CDATA[CSS学习简介与作用 CSS 指层叠样式表(Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式表能实现内容与样式的分离 CSS用途：外观美化，布局，定位等 样式通常存储在样式表中 样式表极大地提高了工作效率##CSS书写位置 外联式:创建一个css后缀文件通过&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;a.css&quot; 内联式: 写在标签中&lt;p style=&quot;color: red;&quot;&gt;内联式&lt;/p&gt; 嵌入式 : 写在head里面的style里面;##样式优先级:##CSS语法格式 选择器{属性: 值; 属性: 值;….} div{color: red;} 多条样式规则 1.多个属性间用分号分隔 2.用冒号声明对应属性值 ##选择器: 标签选择器 [element] 类名选择器 .class ID选择器 #id 并集选择器 [element],[element] 后代选择器 div p 子代选择器 div&gt;p 标签指定式选择器 div.class 通配符选择器 *{} CSS类名规则 类名不能以数字开头或者以纯数字定义类名 类名不推荐（不允许）使用汉字定义类名 不能以特殊符号或者以特殊符号开头定义类名（“_”除外） 个人不推荐使用标签名定义类名。 推荐使用有意义的单词定义类名。 有多个单词的命名方式： 使用“ _”分割 如：header_nav —-class推荐 使用“ -”分割 如： header-nav 驼峰式命名 如：headerNav —-id推荐 样式_命名 外套wrap——————用于最外层头部 header—————-用于头部主要内容 main————用于主体内容（中部）左侧 main_left————-左侧布局右侧 main_right———–右侧布局导航条 nav—————–网页菜单导航条内容 content—————用于网页中部主体底部 footer—————–用于底部 样式属性:文字 font-size: 设置文字大小 浏览器默认字体大小16px; font-weight: normal； 默认值设置文字是否加粗显示100-900： 400=noraml 700=bold; font-style: 设置文字是否斜体显示。默认值： normal 文字正常显示。 斜体显示： font-family: 设置文字字体。可以同时设置多个 font属性联写： font: font-style font-weight font-size/line-height font-family 注意:fout属性连写必须有fout-size和fout-family并且fout-size必须在fout-family前 line-height （行高） 行高等于高度可以让文本垂直居中 text-align （对齐） letter-spacing （字符间距） text-decoration （文本修饰 ）###背景属性: background （缩写形式） background-color（背景色 ） background-image（背景图 ） background-repeat（背景图重复方式 ） background-position（位置坐标、偏移量） opacity透明度 不兼容 取值范围0到1之间 0 完全透明 1 不透明 ie9以下的用filter:alpha(opacity=数值); 取值范围0-100 0透明,100不透明 透明图片设置 列表li常用属性 list-style 典型应用导航 ###超链接样式的特殊性 文本或图像加上链接，将失去原样式而继承链接的样式超链接样式的四种状态: 未访问状态（a:link ） 已访问状态（a:visited ） 鼠标移上状态（a:hover ） 激活选定状态（a:active ） 盒子模型(重点) 作用： 进行网页布局（画盒子） 组成： 边框（border）： 盒子的边框 内边距（padding）: 内容与边框之间的距离 外边距（margin）: 盒子与盒子之间的距离 盒子属性,每个属性都有四个方向,可统一设置或四边分开设置属性 margin（外边距/边界） border（边框） border-color 边框颜色 border-width 边框宽度 border-style 边框样式 padding（内边距/填充 ） 元素的实际占位（实际宽、高） 盒子高度 = height属性 + 上下填充高度 + 上下边框高度 盒子宽度 = width属性 + 左右填充宽度 + 左右边框宽度 ##布局方式 实现布局步骤: 分析页面的分块结构，形成HTML组织结构 从外往内 从上往下 从左往右 编写每个DIV块的CSS控制定位]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML从0开始]]></title>
      <url>%2F2017%2F04%2F10%2F0101-html%2F</url>
      <content type="text"><![CDATA[HTML 教程HTML简介 HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言 (Hyper TextMarkup Language) HTML 使用标记标签来描述网页 HTML文件的扩展名为.html 或 .htm 编辑工具 Sublime Hbuilder Webstorm ………. 文档结构 一个HTML网页由两部分组成 – head头部部分和body主体部分: 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;这是文档的标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这是文档的内容 --&gt; &lt;/body&gt;&lt;/html&gt; 基本语法 &lt;标记名&gt;最简单的网页&lt;/标记名&gt; &lt;title&gt;我的第一个页面&lt;/title&gt; &lt;标记名 属性名=“ 属性值”&gt;文本&lt;/标记名&gt; &lt;body bgcolor=“red”&gt;背景红色&lt;/body&gt; &lt;标记名&gt; 我想学做网页&lt;br&gt;是呀！我也想学! &lt;html&gt;…&lt;/html&gt;:网页内容以&lt;html&gt;开始&lt;/html&gt; &lt;head&gt;…&lt;/head&gt;(网页头部) &lt;title&gt;…&lt;title&gt;标记 网页标题 &lt;link&gt;标记&lt;link href=“style.css” rel=“stylesheet” type=“text/css”&gt;用于载入外部CSS文件 html01_05HTML基本语法 &lt;meta&gt;标记 描述文档类型、字符编码和搜索关键字 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; 提供搜索关键字:&lt;meta name= &quot;keywords&quot; content= &quot;淘宝,网上购物,在线交易,交易市场&quot; /&gt; 内容描述信息，方便搜索引擎的搜索:&lt;meta name= &quot;description&quot; content= &quot;淘宝网-亚洲最大、最安全的网上交易平台，提供各类服饰、美容、家居、数码、 ……&quot; /&gt; &lt;script&gt;…&lt;script&gt; 标记 &lt;script src=“abc.js”&gt;&lt;/script&gt; 当前网页载入一个 abc.js文件 &lt;style&gt;…&lt;style&gt;标记 在此标记之间定义本网页的CSS样式HTML基本语法 …标记 它定义了网页上显示的主要内容与显示格式，是整个网页的核心，网页中要真正现实的内容都包含在本标记中。 &lt;body&gt;有很多属性，这些属性用于设定网页的总体风格，可以定义页面的背景图像、背景颜色、文字颜色、超文本链接的颜色。HTML基本语法 标签(标记)注释标记 格式：&lt;!– 注释内容--&gt; 注释为文中的不同部分加上说明，以方便日后阅读和修改, 注释内容不显示在页面上。 标题标签 h1, h2 … h6是标题标签, 其中: h1是大标题, 一个页面一般只有一个h1; h2常用来表示副标题.水平线标签 &lt;hr /&gt; &lt;hr /&gt;为单个标签的闭合形式 横线用于内容分割 通过 size 和 width 属性设置水平线的尺寸: &lt;hr size=&quot;1&quot; width=&quot;100px&quot;/&gt; &lt;hr size=&quot;2&quot; width=&quot;100&quot;/&gt; &lt;hr size=&quot;4&quot; width=&quot;50%&quot;/&gt; 效果图:html中的数值单位: px (默认就是px) 具体数值 % 就是百分比 表示的是父元素的百分比 文本格式化标签_标签描述 (不推荐使用)| 标签名 | 标签描述 | 预览 | | ------------- |:-------------:|-----------| | `&lt;b&gt;` | 定义粗体文本 |&lt;b&gt;我是b标签&lt;/b&gt;| |`&lt;big&gt;` | 定义大号字 |&lt;big&gt;我是big标签&lt;/big&gt;| | `&lt;em&gt;` | 定义着重文字 |&lt;em&gt;我是em标签&lt;/em&gt;| | `&lt;i&gt;` | 定义斜体字 |&lt;i&gt;我是i标签&lt;/i&gt;| | `&lt;small&gt;` | 定义小号字 |&lt;small&gt;我是small标签&lt;/small&gt;| | `&lt;strong&gt;` | 定义加重语气 |&lt;strong&gt;我是strong标签&lt;/strong&gt;| | `&lt;sub&gt;` | 定义下标字 |你好&lt;sub&gt;我是sub标签&lt;/sub&gt;| | `&lt;sup&gt;` | 定义上标字 |你好&lt;sup&gt;我是sup标签&lt;/sup&gt;| | `&lt;ins&gt;` | 定义插入字 |&lt;ins&gt;我是ins标签&lt;/ins&gt;| | `&lt;del&gt;` | 定义删除字 |&lt;del&gt;我是del标签&lt;/del&gt;| 有序列表 &lt;ol&gt;&lt;/ol&gt; 通过&lt;ol&gt;标签的 start 属性, 可以设置列表的起始值 通过&lt;ol&gt;标签的 type 属性, 可以设置列表中使用的标记类型 有5个值: 1 – 数字; A – 大写母; a – 小写字母; I – 大写罗马数字; i – 小写罗马数字; 效果图:无序列表 &lt;ul&gt;&lt;/ul&gt; type 属性, 可以设置列表中使用的标记类型 disc 默认值。实心圆。 circle 空心圆。 square 实心方块。定义描述标签 dl dt dd dt 标题 dd 描述 表格标签 &lt;table&gt;&lt;/table&gt; &lt;table&gt;标签用来定义表格, 常用属性: border: 表格的边框; width: 表格的宽度; cellpadding: 单元边沿与内容的间距; cellspacing: 单元格之间的空白; &lt;caption&gt;标签用来定义表格标题: caption 必须紧随 table 之后, 一个表格只能有一个标题. &lt;td&gt;和&lt;th&gt;具有两个重要属性, 可以用来合并单元格: colspan: 横向合并单元格; rowspan: 纵向合并单元格; 演示: 分区标签&lt;div&gt;&lt;/div&gt; div标签其实就是一个划分逻辑区域的标签,常用作容器,常用来包含文字.图片等. 图片标签 是图像标签, 它是自闭和标签. src属性(必须): 图片的位置; alt属性(必须): 图片显示不出来时的替代文本. title属性: 鼠标滑过图片时显示的文字提示.范围标签&lt;span&gt; ：显示某行内的独特样式超链接 &lt;a href=&quot;http://www.baidu.com&quot; &gt; 百度 &lt;a/&gt; 语法: &lt;a href=&quot;链接地址&quot; &gt;链接热点文本或图像&lt;/a&gt; target属性: _blank:在新窗口打开被链接的文档 _self:在相同的框架中打开被连接的文档 _parent:在父框架集中打开被连接的文档 _top:在整个窗口中被打开链接的文档 framename: 在指定的框架中打开被连接的文档 锚链接 &lt;a&gt;&lt;a/&gt; 定义一个锚点标记 给一个元素设置一个id a标签的href里面写上#锚点标记特殊符号(字符实体) 空格：&amp;nbsp; 大于(&gt;)：&amp;gt; 小于(&lt;）: &amp;lt; 引号（” ）：&amp;quot;表单 标签代表表单, 它用于向服务器传输数据, 例如搜索框就是一个典型的表单: 常用属性: name: 用于定义表单的名称; action: 一个URL, 定义提交表单时向何处发送数据; method: 定义发送表单数据时的HTTP方法(get/post); POST和GET的区别: get只能提交少量数据; post可以携带大量数据; get提交时数据会在地址栏显示, 安全性差; post方式更加安全; 表单元素的中可以包含各种不同的元素: 表单元素的基本格式 : 语法: &lt;input name=&quot;表单元素名称&quot; type=&quot;类型&quot; value=&quot;值&quot; size=&quot;显示宽度&quot; maxlength=&quot;对大长度&quot; checked=&quot;是否选中&quot; /&gt; name:控件的名称 type:控件类型 value:控件的初始值 size:控件的初始宽度 maxlength:控件的最大长度 checked:控件是否被选中 type类型,作用: 框架的两类用途： 显示多窗口页面—使用框架集 语法: `&lt;frameset cols=&quot;25%,50%,*&quot; rows =&quot;50%,*&quot; border=&quot;5&quot;&gt;` `&lt;frame src=&quot;../example/a.html &quot;&gt;` `&lt;/frameset&gt;` cols :% 作用 :定义框架集中列的数目和尺寸 rows :% 作用:定义框架集中行的数目和尺寸 src : 引用各窗口要显示的网页文件 页面复用—使用&lt;iframe/&gt;内嵌框架 &lt;iframe&gt;语法： &lt;iframe src=&quot;../example/b.html&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt; 实例：&lt;iframe src=&quot;http://www.taobao.com&quot; width=&quot;100%&quot; height=&quot;500&quot;&gt;&lt;/iframe&gt;]]></content>
    </entry>

    
  
  
</search>
